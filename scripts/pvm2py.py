#!/usr/bin/env python3
"""
PVM to Python Converter

Converts PathView .pvm/.json files to standalone PathSim Python scripts.

Usage:
    python scripts/pvm2py.py model.pvm                # outputs model.py
    python scripts/pvm2py.py model.pvm -o output.py   # custom output path
    python scripts/pvm2py.py model.pvm --stdout        # print to stdout
"""

import argparse
import json
import re
import sys
from collections import defaultdict
from datetime import datetime, timezone
from pathlib import Path
from typing import Any


# =============================================================================
# Registry
# =============================================================================

def load_registry(registry_path: Path) -> dict:
    """Load the JSON registry generated by extract.py."""
    if not registry_path.exists():
        print(f"Error: Registry not found at {registry_path}", file=sys.stderr)
        print("Run 'npm run extract' or 'python scripts/extract.py' first.", file=sys.stderr)
        sys.exit(1)
    with open(registry_path, encoding="utf-8") as f:
        return json.load(f)


# =============================================================================
# Code builder utilities (ported from codeBuilder.ts)
# =============================================================================

def sanitize_name(name: str) -> str:
    """Sanitize a name for use as a Python variable."""
    if not name:
        return ""
    sanitized = ""
    for char in name:
        if re.match(r"[a-zA-Z0-9_]", char):
            sanitized += char
        elif char == " ":
            sanitized += "_"
    if sanitized and sanitized[0].isdigit():
        sanitized = "n_" + sanitized
    return sanitized.lower()


def generate_param_string(params: dict, valid_params: set[str], multi_line: bool = False) -> str:
    """Generate parameter string for Python constructor calls."""
    parts = []
    for name, value in params.items():
        if value is None or value == "":
            continue
        if name.startswith("_"):
            continue
        if name not in valid_params:
            continue
        parts.append(f"{name}={value}")

    if multi_line and parts:
        indent = "    "
        return "\n" + ",\n".join(indent + p for p in parts) + "\n"
    return ", ".join(parts)


def group_connections_by_source(
    connections: list[dict], node_vars: dict[str, str]
) -> list[dict]:
    """Group connections by source for multi-target Connection syntax."""
    groups: dict[str, dict] = {}
    for conn in connections:
        source_var = node_vars.get(conn["sourceNodeId"])
        target_var = node_vars.get(conn["targetNodeId"])
        if not source_var or not target_var:
            continue
        key = f"{conn['sourceNodeId']}:{conn['sourcePortIndex']}"
        if key not in groups:
            groups[key] = {
                "sourceVar": source_var,
                "sourcePort": conn["sourcePortIndex"],
                "targets": [],
            }
        groups[key]["targets"].append({
            "varName": target_var,
            "port": conn["targetPortIndex"],
        })
    return list(groups.values())


def generate_connection_lines(
    connections: list[dict], node_vars: dict[str, str], indent: str = "    "
) -> list[str]:
    """Generate Connection() lines from connections."""
    lines = []
    for group in group_connections_by_source(connections, node_vars):
        source = f"{group['sourceVar']}[{group['sourcePort']}]"
        targets = ", ".join(
            f"{t['varName']}[{t['port']}]" for t in group["targets"]
        )
        lines.append(f"{indent}Connection({source}, {targets}),")
    return lines


# =============================================================================
# Default simulation settings (fallback when .pvm has empty strings)
# =============================================================================

DEFAULT_SETTINGS = {
    "duration": "10.0",
    "dt": "0.01",
    "solver": "SSPRK22",
    "atol": "1e-6",
    "rtol": "1e-3",
    "ftol": "1e-12",
    "dt_min": "1e-12",
    "dt_max": None,
}


def get_setting(settings: dict, key: str) -> str | None:
    """Get setting value, falling back to defaults for empty strings."""
    value = settings.get(key, "")
    if value == "" or value is None:
        return DEFAULT_SETTINGS.get(key)
    return str(value)


# =============================================================================
# Node collection and import resolution
# =============================================================================

def collect_all_nodes(nodes: list[dict]) -> list[dict]:
    """Recursively collect all nodes including those inside subsystems."""
    result = []
    for node in nodes:
        result.append(node)
        if node.get("type") == "Subsystem" and node.get("graph"):
            result.extend(collect_all_nodes(node["graph"].get("nodes", [])))
    return result


def collect_all_events(events: list[dict], nodes: list[dict]) -> list[dict]:
    """Collect all events including those inside subsystems."""
    result = list(events)
    for node in nodes:
        if node.get("type") == "Subsystem" and node.get("graph"):
            sub_events = node["graph"].get("events", [])
            result.extend(sub_events)
            result.extend(
                collect_all_events([], node["graph"].get("nodes", []))
            )
    return result


def resolve_block_imports(
    nodes: list[dict], registry: dict
) -> dict[str, list[str]]:
    """Group block classes by import path. Returns {importPath: [className, ...]}."""
    all_nodes = collect_all_nodes(nodes)
    imports: dict[str, set[str]] = defaultdict(set)
    for node in all_nodes:
        node_type = node.get("type", "")
        if node_type in ("Subsystem", "Interface"):
            continue
        block_info = registry["blocks"].get(node_type)
        if block_info:
            imports[block_info["importPath"]].add(block_info["blockClass"])
    return {path: sorted(classes) for path, classes in imports.items()}


def resolve_event_imports(
    events: list[dict], nodes: list[dict], registry: dict
) -> dict[str, list[str]]:
    """Group event classes by import path."""
    all_events = collect_all_events(events, nodes)
    imports: dict[str, set[str]] = defaultdict(set)
    for event in all_events:
        event_type = event.get("type", "")
        # Event type is like "pathsim.events.ZeroCrossing" â€” extract class name
        event_name = event_type.rsplit(".", 1)[-1] if "." in event_type else event_type
        event_info = registry["events"].get(event_name)
        if event_info:
            imports[event_info["importPath"]].add(event_info["eventClass"])
    return {path: sorted(classes) for path, classes in imports.items()}


# =============================================================================
# Subsystem code generation
# =============================================================================

def generate_subsystem_code(
    node: dict,
    node_vars: dict[str, str],
    var_names: list[str],
    lines: list[str],
    registry: dict,
    prefix: str = "",
) -> str:
    """Generate code for a subsystem and its contents. Returns variable name."""
    graph = node.get("graph", {})
    child_nodes = graph.get("nodes", [])
    child_connections = graph.get("connections", [])
    child_events = graph.get("events", [])

    # Generate subsystem variable name
    var_name = sanitize_name(node["name"])
    if not var_name or var_name in var_names:
        var_name = f"subsystem_{len(var_names)}"
    var_names.append(var_name)
    node_vars[node["id"]] = var_name

    sub_prefix = prefix + var_name + "_"

    # Separate interface nodes from internal blocks
    interface_nodes = [n for n in child_nodes if n.get("type") == "Interface"]
    internal_blocks = [n for n in child_nodes if n.get("type") != "Interface"]

    internal_var_names: list[str] = []
    internal_node_vars: dict[str, str] = {}

    lines.append("")
    lines.append(f"# Subsystem: {node['name']}")

    # Generate Interface blocks
    for iface in interface_nodes:
        iface_var = sub_prefix + "interface"
        internal_var_names.append(iface_var)
        internal_node_vars[iface["id"]] = iface_var
        lines.append(f"{iface_var} = Interface()")

    # Generate internal blocks
    for child in internal_blocks:
        if child.get("type") == "Subsystem":
            generate_subsystem_code(
                child, internal_node_vars, internal_var_names,
                lines, registry, sub_prefix,
            )
        else:
            block_info = registry["blocks"].get(child.get("type", ""))
            if not block_info:
                continue
            child_var = sub_prefix + sanitize_name(child["name"])
            if not child_var or child_var in internal_var_names:
                child_var = f"{sub_prefix}block_{len(internal_var_names)}"
            internal_var_names.append(child_var)
            internal_node_vars[child["id"]] = child_var

            valid_params = set(block_info["params"])
            params = generate_param_string(
                child.get("params", {}), valid_params, multi_line=True
            )
            if params:
                lines.append(f"{child_var} = {block_info['blockClass']}({params})")
            else:
                lines.append(f"{child_var} = {block_info['blockClass']}()")

    # Propagate internal node vars to parent
    for nid, nvar in internal_node_vars.items():
        node_vars[nid] = nvar

    # Generate internal events
    event_var_names: list[str] = []
    for event in child_events:
        event_type = event.get("type", "")
        event_name = event_type.rsplit(".", 1)[-1] if "." in event_type else event_type
        event_info = registry["events"].get(event_name)
        if not event_info:
            continue
        evt_var = sub_prefix + sanitize_name(event["name"])
        if not evt_var or evt_var in var_names or evt_var in event_var_names:
            evt_var = f"{sub_prefix}event_{len(event_var_names)}"
        event_var_names.append(evt_var)

        valid_params = set(event_info["params"])
        params = generate_param_string(event.get("params", {}), valid_params, multi_line=True)
        if params:
            lines.append(f"{evt_var} = {event_info['eventClass']}({params})")
        else:
            lines.append(f"{evt_var} = {event_info['eventClass']}()")

    # Subsystem constructor
    lines.append(f"{var_name} = Subsystem(")
    lines.append("    blocks=[")
    for v in internal_var_names:
        lines.append(f"        {v},")
    lines.append("    ],")
    lines.append("    connections=[")
    for line in generate_connection_lines(child_connections, internal_node_vars, "        "):
        lines.append(line)
    lines.append("    ],")
    if child_events:
        lines.append("    events=[")
        for evt_var in event_var_names:
            lines.append(f"        {evt_var},")
        lines.append("    ],")
    lines.append(")")

    return var_name


# =============================================================================
# Main code generation
# =============================================================================

def generate_python(pvm: dict, registry: dict, source_name: str = "") -> str:
    """Generate formatted standalone Python code from a .pvm file."""
    lines: list[str] = []
    divider = "# " + "\u2500" * 76

    graph = pvm.get("graph", {})
    nodes = graph.get("nodes", [])
    connections = graph.get("connections", [])
    events = pvm.get("events", [])
    code_context = pvm.get("codeContext", {}).get("code", "")
    settings = pvm.get("simulationSettings", {})

    has_subsystems = any(n.get("type") == "Subsystem" for n in nodes)
    block_imports = resolve_block_imports(nodes, registry)
    event_imports = resolve_event_imports(events, nodes, registry)

    # Header
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
    lines.append("#!/usr/bin/env python3")
    lines.append("# -*- coding: utf-8 -*-")
    lines.append('"""')
    lines.append("PathSim Simulation")
    lines.append("==================")
    lines.append("")
    if source_name:
        lines.append(f"Converted from: {source_name}")
    lines.append(f"Generated by pvm2py on {timestamp}")
    lines.append("https://view.pathsim.org")
    lines.append("")
    lines.append("PathSim documentation: https://docs.pathsim.org")
    lines.append('"""')
    lines.append("")

    # Imports
    lines.append(divider)
    lines.append("# IMPORTS")
    lines.append(divider)
    lines.append("")
    lines.append("import numpy as np")
    lines.append("import matplotlib.pyplot as plt")
    lines.append("")

    if has_subsystems:
        lines.append("from pathsim import Simulation, Connection, Subsystem, Interface")
    else:
        lines.append("from pathsim import Simulation, Connection")

    # Block imports grouped by import path
    for import_path, classes in sorted(block_imports.items()):
        lines.append(f"from {import_path} import (")
        for i, cls in enumerate(classes):
            comma = "," if i < len(classes) - 1 else ""
            lines.append(f"    {cls}{comma}")
        lines.append(")")

    solver = get_setting(settings, "solver") or "SSPRK22"
    lines.append(f"from pathsim.solvers import {solver}")

    # Event imports grouped by import path
    for import_path, classes in sorted(event_imports.items()):
        lines.append(f"from {import_path} import {', '.join(classes)}")

    lines.append("")

    # Code context
    if code_context.strip():
        lines.append(divider)
        lines.append("# USER-DEFINED CODE")
        lines.append(divider)
        lines.append("")
        lines.append(code_context.strip())
        lines.append("")

    # Blocks
    lines.append(divider)
    lines.append("# BLOCKS")
    lines.append(divider)

    node_vars: dict[str, str] = {}
    var_names: list[str] = []

    # Generate subsystems first
    for node in nodes:
        if node.get("type") == "Subsystem":
            generate_subsystem_code(node, node_vars, var_names, lines, registry)

    # Generate regular blocks (excluding subsystems and interfaces)
    regular_nodes = [
        n for n in nodes
        if n.get("type") not in ("Subsystem", "Interface")
    ]

    if regular_nodes:
        lines.append("")

    for i, node in enumerate(regular_nodes):
        block_info = registry["blocks"].get(node.get("type", ""))
        if not block_info:
            continue

        var_name = sanitize_name(node["name"])
        if not var_name or var_name in var_names:
            var_name = f"block_{i}"
        var_names.append(var_name)
        node_vars[node["id"]] = var_name

        valid_params = set(block_info["params"])
        params = generate_param_string(node.get("params", {}), valid_params, multi_line=True)
        if params:
            lines.append(f"{var_name} = {block_info['blockClass']}({params})")
        else:
            lines.append(f"{var_name} = {block_info['blockClass']}()")

    # Blocks list
    lines.append("")
    lines.append("blocks = [")
    for v in var_names:
        lines.append(f"    {v},")
    lines.append("]")
    lines.append("")

    # Connections
    lines.append(divider)
    lines.append("# CONNECTIONS")
    lines.append(divider)
    lines.append("")
    if not connections:
        lines.append("connections = []")
    else:
        lines.append("connections = [")
        for line in generate_connection_lines(connections, node_vars, "    "):
            lines.append(line)
        lines.append("]")
    lines.append("")

    # Events
    if events:
        lines.append(divider)
        lines.append("# EVENTS")
        lines.append(divider)
        lines.append("")

        event_var_names: list[str] = []
        for event in events:
            event_type = event.get("type", "")
            event_name = event_type.rsplit(".", 1)[-1] if "." in event_type else event_type
            event_info = registry["events"].get(event_name)
            if not event_info:
                continue

            evt_var = sanitize_name(event["name"])
            if not evt_var or evt_var in var_names or evt_var in event_var_names:
                evt_var = f"event_{len(event_var_names)}"
            event_var_names.append(evt_var)

            valid_params = set(event_info["params"])
            params = generate_param_string(event.get("params", {}), valid_params, multi_line=True)
            if params:
                lines.append(f"{evt_var} = {event_info['eventClass']}({params})")
            else:
                lines.append(f"{evt_var} = {event_info['eventClass']}()")

        lines.append("")
        lines.append("events = [")
        for v in event_var_names:
            lines.append(f"    {v},")
        lines.append("]")
        lines.append("")

    # Simulation
    lines.append(divider)
    lines.append("# SIMULATION")
    lines.append(divider)
    lines.append("")

    has_events = bool(events)
    lines.append("sim = Simulation(")
    lines.append("    blocks,")
    lines.append("    connections,")
    if has_events:
        lines.append("    events,")
    lines.append(f"    Solver={solver},")
    lines.append(f"    dt={get_setting(settings, 'dt')},")
    lines.append(f"    dt_min={get_setting(settings, 'dt_min')},")

    dt_max = get_setting(settings, "dt_max")
    if dt_max:
        lines.append(f"    dt_max={dt_max},")

    lines.append(f"    tolerance_lte_rel={get_setting(settings, 'rtol')},")
    lines.append(f"    tolerance_lte_abs={get_setting(settings, 'atol')},")
    lines.append(f"    tolerance_fpi={get_setting(settings, 'ftol')},")
    lines.append(")")
    lines.append("")

    # Main block
    lines.append(divider)
    lines.append("# MAIN")
    lines.append(divider)
    lines.append("")
    lines.append("if __name__ == '__main__':")
    lines.append("")
    lines.append("    # Run simulation")
    lines.append(f"    sim.run(duration={get_setting(settings, 'duration')})")
    lines.append("")
    lines.append("    # Plot results")
    lines.append("    sim.plot()")
    lines.append("    plt.show()")
    lines.append("")

    return "\n".join(lines)


# =============================================================================
# CLI
# =============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Convert PathView .pvm files to standalone PathSim Python scripts",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python scripts/pvm2py.py model.pvm
  python scripts/pvm2py.py model.pvm -o simulation.py
  python scripts/pvm2py.py model.pvm --stdout
""",
    )
    parser.add_argument("input", help="Input .pvm or .json file")
    parser.add_argument("-o", "--output", help="Output .py file (default: <input>.py)")
    parser.add_argument("--stdout", action="store_true", help="Print to stdout instead of file")
    parser.add_argument(
        "--registry",
        help="Path to registry.json (default: scripts/generated/registry.json)",
    )
    args = parser.parse_args()

    input_path = Path(args.input)
    if not input_path.exists():
        print(f"Error: Input file not found: {input_path}", file=sys.stderr)
        sys.exit(1)

    # Load registry
    if args.registry:
        registry_path = Path(args.registry)
    else:
        registry_path = Path(__file__).parent / "generated" / "registry.json"
    registry = load_registry(registry_path)

    # Load .pvm file
    with open(input_path, encoding="utf-8") as f:
        pvm = json.load(f)

    # Generate Python code
    python_code = generate_python(pvm, registry, source_name=input_path.name)

    if args.stdout:
        sys.stdout.buffer.write(python_code.encode("utf-8"))
    else:
        if args.output:
            output_path = Path(args.output)
        else:
            output_path = input_path.with_suffix(".py")
        output_path.write_text(python_code, encoding="utf-8")
        print(f"Converted: {input_path} -> {output_path}")


if __name__ == "__main__":
    main()
