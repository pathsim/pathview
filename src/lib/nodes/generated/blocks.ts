// Auto-generated by scripts/extract-blocks.py - DO NOT EDIT
// Re-run 'python scripts/extract-blocks.py' to update

import type { NodeCategory } from '../types';

export interface ExtractedParam {
  type: string;
  default: string | null;
  description: string;
  min?: number;
  max?: number;
  options?: string[];
}

export interface ExtractedBlock {
  blockClass: string;
  description: string;
  docstringHtml: string;
  params: Record<string, ExtractedParam>;
  inputs: string[];
  outputs: string[];
}

export interface UIOverride {
  maxInputs?: number | null;
  maxOutputs?: number | null;
  defaultInputs?: string[];
  defaultOutputs?: string[];
  shape?: string;
}

export const extractedBlocks: Record<string, ExtractedBlock> = 
{
  "Constant": {
    "blockClass": "Constant",
    "description": "Produces a constant output signal (SISO)",
    "docstringHtml": "<p>Produces a constant output signal (SISO)</p>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>constant defining block output</dd>\n</dl>\n</div>\n",
    "params": {
      "value": {
        "type": "integer",
        "default": "1",
        "description": "constant defining block output"
      }
    },
    "inputs": [],
    "outputs": [
      "out"
    ]
  },
  "Source": {
    "blockClass": "Source",
    "description": "Source that produces an arbitrary time dependent output,",
    "docstringHtml": "<p>Source that produces an arbitrary time dependent output,\ndefined by the func (callable).</p>\n<div class=\"math\">\n\\begin{equation*}\ny(t) = \\mathrm{func}(t)\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"note\">\n<h3>Note</h3>\n<p>This block is purely algebraic and its internal function (<cite>func</cite>) will\nbe called multiple times per timestep, each time when <cite>Simulation._update(t)</cite>\nis called in the global simulation loop.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h3>Example</h3>\n<p>For example a ramp:</p>\n<pre class=\"code python literal-block\">\nfrom pathsim.blocks import Source\n\nsrc = Source(lambda t : t)\n</pre>\n<p>or a simple sinusoid with some frequency:</p>\n<pre class=\"code python literal-block\">\nimport numpy as np\nfrom pathsim.blocks import Source\n\n#some parameter\nomega = 100\n\n#the function that gets evaluated\ndef f(t):\n    return np.sin(omega * t)\n\nsrc = Source(f)\n</pre>\n<p>Because the <cite>Source</cite> block only has a single argument, it can be\nused to decorate a function and make it a <cite>PathSim</cite> block. This might\nbe handy in some cases to keep definitions concise and localized\nin the code:</p>\n<pre class=\"code python literal-block\">\nimport numpy as np\nfrom pathsim.blocks import Source\n\n#does the same as the definition above\n\n&#64;Source\ndef src(t):\n    omega = 100\n    return np.sin(omega * t)\n\n#'src' is now a PathSim block\n</pre>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>function defining time dependent block output</dd>\n</dl>\n</div>\n",
    "params": {
      "func": {
        "type": "callable",
        "default": null,
        "description": "function defining time dependent block output"
      }
    },
    "inputs": [],
    "outputs": [
      "out"
    ]
  },
  "SinusoidalSource": {
    "blockClass": "SinusoidalSource",
    "description": "Source block that generates a sinusoid wave",
    "docstringHtml": "<p>Source block that generates a sinusoid wave</p>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>frequency <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>frequency of the sinusoid</dd>\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the sinusoid</dd>\n<dt>phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>phase of the sinusoid</dd>\n</dl>\n</div>\n",
    "params": {
      "frequency": {
        "type": "integer",
        "default": "1",
        "description": "frequency of the sinusoid"
      },
      "amplitude": {
        "type": "integer",
        "default": "1",
        "description": "amplitude of the sinusoid"
      },
      "phase": {
        "type": "integer",
        "default": "0",
        "description": "phase of the sinusoid"
      }
    },
    "inputs": [],
    "outputs": [
      "out"
    ]
  },
  "StepSource": {
    "blockClass": "StepSource",
    "description": "Discrete time unit step source block.",
    "docstringHtml": "<p>Discrete time unit step source block.</p>\n<p>Utilizes a scheduled event to set the block output\nto the specified output levels at the defined event times.</p>\n<p>The arguments can be vectorial and in that case, the output is set to the\namplitude that corresponds to the defined delay like a zero-order-hold stage.\nThis functionality enables adding external or time series measurement data\ninto the system.</p>\n<div class=\"section\" id=\"examples\">\n<h3>Examples</h3>\n<p>This is how to use the source as a unit step source:</p>\n<pre class=\"code python literal-block\">\nfrom pathsim.blocks import StepSource\n\n#default, starts at 0, jumps to 1\nstp = StepSource()\n</pre>\n<p>And this is how to configure it with multiple consecutive steps:</p>\n<pre class=\"code python literal-block\">\nfrom pathsim.blocks import StepSource\n\n#starts at 0, jumps to 1 at 1, jumps to -1 at 2 and jumps back to 0 at 3\nstp = StepSource(amplitude=[1, -1, 0], tau=[1, 2, 3])\n</pre>\n<p>Similarly implementing measured time series data via zoh:</p>\n<pre class=\"code python literal-block\">\nimport numpy as np\nfrom pathsim.blocks import StepSource\n\n#some random time series arrays\ntimes, data = np.linspace(0, 100, 1000), np.random.rand(1000)\n\n#pass them to the block\nstp = StepSource(amplitude=data, tau=times)\n</pre>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float | list[float]</span></dt>\n<dd>amplitude of the step signal, or amplitudes / output\nlevels of the multiple steps</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float | list[float]</span></dt>\n<dd>delay of the step, or delays of the different steps</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>Evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ScheduleList</span></dt>\n<dd>internal scheduled event directly accessible</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ScheduleList]</span></dt>\n<dd>list of interna events</dd>\n</dl>\n</div>\n",
    "params": {
      "amplitude": {
        "type": "integer",
        "default": "1",
        "description": "amplitude of the step signal, or amplitudes / output levels of the multiple steps"
      },
      "tau": {
        "type": "number",
        "default": "0.0",
        "description": "delay of the step, or delays of the different steps"
      }
    },
    "inputs": [],
    "outputs": [
      "out"
    ]
  },
  "PulseSource": {
    "blockClass": "PulseSource",
    "description": "Generates a periodic pulse waveform with defined rise and fall times",
    "docstringHtml": "<p>Generates a periodic pulse waveform with defined rise and fall times\nusing a hybrid approach with scheduled events and continuous updates.</p>\n<p>Scheduled events trigger phase changes (low, rising, high, falling),\nand the <cite>update</cite> method calculates the output value based on the\ncurrent phase, performing linear interpolation during rise and fall.</p>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Peak amplitude of the pulse. Default is 1.0.</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Period of the pulse train. Must be positive. Default is 1.0.</dd>\n<dt>t_rise <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Duration of the rising edge. Default is 0.0.</dd>\n<dt>t_fall <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Duration of the falling edge. Default is 0.0.</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Initial delay before the first pulse cycle begins. Default is 0.0.</dd>\n<dt>duty <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Duty cycle, ratio of the pulse ON duration (plateau time only)\nto the total period T (must be between 0 and 1). Default is 0.5.\nThe high plateau duration is <cite>T * duty</cite>.</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>Internal scheduled events triggering phase transitions.</dd>\n<dt>_phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str</span></dt>\n<dd>Current phase of the pulse ('low', 'rising', 'high', 'falling').</dd>\n<dt>_phase_start_time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Simulation time when the current phase began.</dd>\n</dl>\n</div>\n",
    "params": {
      "amplitude": {
        "type": "number",
        "default": "1.0",
        "description": "Peak amplitude of the pulse. Default is 1.0."
      },
      "T": {
        "type": "number",
        "default": "1.0",
        "description": "Period of the pulse train. Must be positive. Default is 1.0."
      },
      "t_rise": {
        "type": "number",
        "default": "0.0",
        "description": "Duration of the rising edge. Default is 0.0."
      },
      "t_fall": {
        "type": "number",
        "default": "0.0",
        "description": "Duration of the falling edge. Default is 0.0."
      },
      "tau": {
        "type": "number",
        "default": "0.0",
        "description": "Initial delay before the first pulse cycle begins. Default is 0.0."
      },
      "duty": {
        "type": "number",
        "default": "0.5",
        "description": "Duty cycle, ratio of the pulse ON duration (plateau time only) to the total period T (must be between 0 and 1). Default is 0.5. The high plateau duration is `T * duty`."
      }
    },
    "inputs": [],
    "outputs": [
      "out"
    ]
  },
  "TriangleWaveSource": {
    "blockClass": "TriangleWaveSource",
    "description": "Source block that generates an analog triangle wave",
    "docstringHtml": "<p>Source block that generates an analog triangle wave</p>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>frequency <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>frequency of the triangle wave</dd>\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the triangle wave</dd>\n<dt>phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>phase of the triangle wave</dd>\n</dl>\n</div>\n",
    "params": {
      "frequency": {
        "type": "integer",
        "default": "1",
        "description": "frequency of the triangle wave"
      },
      "amplitude": {
        "type": "integer",
        "default": "1",
        "description": "amplitude of the triangle wave"
      },
      "phase": {
        "type": "integer",
        "default": "0",
        "description": "phase of the triangle wave"
      }
    },
    "inputs": [],
    "outputs": [
      "out"
    ]
  },
  "SquareWaveSource": {
    "blockClass": "SquareWaveSource",
    "description": "Discrete time square wave source.",
    "docstringHtml": "<p>Discrete time square wave source.</p>\n<p>Utilizes scheduled events to periodically set\nthe block output at discrete times.</p>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the square wave signal</dd>\n<dt>frequency <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>frequency of the square wave signal</dd>\n<dt>phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>phase of the square wave signal</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>internal scheduled events</dd>\n</dl>\n</div>\n",
    "params": {
      "amplitude": {
        "type": "integer",
        "default": "1",
        "description": "amplitude of the square wave signal"
      },
      "frequency": {
        "type": "integer",
        "default": "1",
        "description": "frequency of the square wave signal"
      },
      "phase": {
        "type": "integer",
        "default": "0",
        "description": "phase of the square wave signal"
      }
    },
    "inputs": [],
    "outputs": [
      "out"
    ]
  },
  "GaussianPulseSource": {
    "blockClass": "GaussianPulseSource",
    "description": "Source block that generates a gaussian pulse",
    "docstringHtml": "<p>Source block that generates a gaussian pulse</p>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the gaussian pulse</dd>\n<dt>f_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>maximum frequency component of the gaussian pulse (steepness)</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>time delay of the gaussian pulse</dd>\n</dl>\n</div>\n",
    "params": {
      "amplitude": {
        "type": "integer",
        "default": "1",
        "description": "amplitude of the gaussian pulse"
      },
      "f_max": {
        "type": "number",
        "default": "1000.0",
        "description": "maximum frequency component of the gaussian pulse (steepness)"
      },
      "tau": {
        "type": "number",
        "default": "0.0",
        "description": "time delay of the gaussian pulse"
      }
    },
    "inputs": [],
    "outputs": [
      "out"
    ]
  },
  "ChirpPhaseNoiseSource": {
    "blockClass": "ChirpPhaseNoiseSource",
    "description": "Chirp source, sinusoid with frequency ramp up and ramp down, plus phase noise.",
    "docstringHtml": "<p>Chirp source, sinusoid with frequency ramp up and ramp down, plus phase noise.</p>\n<p>This works by using a time dependent triangle wave for the frequency\nand integrating it with a numerical integration engine to get a\ncontinuous phase. This phase is then used to evaluate a sinusoid.</p>\n<p>Additionally the chirp source can have white and cumulative phase noise.\nMathematically it looks like this for the contributions to the phase from\nthe triangular wave:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\varphi_t(t) = \\int_0^t \\mathrm{tri}_{f_0, B, T}(\\tau) \\, d\\tau\n\\end{equation*}\n</div>\n<p>And from the white (w) and cumulative (c) noise:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\varphi_n(t) = \\sigma_w \\, n_w(t) + \\sigma_c \\int_0^t n_c(\\tau) \\, d\\tau\n\\end{equation*}\n</div>\n<p>The phase contributions are then used to evaluate a sinusoid to get the final chirp signal:</p>\n<div class=\"math\">\n\\begin{equation*}\ny(t) = A \\sin(\\varphi_t(t) + \\varphi_n(t) + \\varphi_0)\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>amplitude <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplitude of the chirp signal</dd>\n<dt>f0 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>start frequency of the chirp signal</dd>\n<dt>BW <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>bandwidth of the frequency ramp of the chirp signal</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>period of the frequency ramp of the chirp signal</dd>\n<dt>phase <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>phase of sinusoid (initial, radians)</dd>\n<dt>sig_cum <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>weight for cumulative phase noise contribution</dd>\n<dt>sig_white <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>weight for white phase noise contribution</dd>\n<dt>sampling_rate <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, None</span></dt>\n<dd>frequency with which phase noise is sampled (Hz). If None,\nnoise is sampled every timestep (default is 10 Hz)</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>noise_1 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>internal noise value for white phase noise</dd>\n<dt>noise_2 <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>internal noise value for cumulative phase noise</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>scheduled event for periodic sampling (only if sampling_rate is set)</dd>\n</dl>\n</div>\n",
    "params": {
      "amplitude": {
        "type": "integer",
        "default": "1",
        "description": "amplitude of the chirp signal"
      },
      "f0": {
        "type": "integer",
        "default": "1",
        "description": "start frequency of the chirp signal"
      },
      "BW": {
        "type": "integer",
        "default": "1",
        "description": "bandwidth of the frequency ramp of the chirp signal"
      },
      "T": {
        "type": "integer",
        "default": "1",
        "description": "period of the frequency ramp of the chirp signal"
      },
      "phase": {
        "type": "integer",
        "default": "0",
        "description": "phase of sinusoid (initial, radians)"
      },
      "sig_cum": {
        "type": "integer",
        "default": "0",
        "description": "weight for cumulative phase noise contribution"
      },
      "sig_white": {
        "type": "integer",
        "default": "0",
        "description": "weight for white phase noise contribution"
      },
      "sampling_rate": {
        "type": "integer",
        "default": "10",
        "description": "frequency with which phase noise is sampled (Hz). If None, noise is sampled every timestep (default is 10 Hz) Attributes ----------"
      }
    },
    "inputs": [],
    "outputs": [
      "out"
    ]
  },
  "ClockSource": {
    "blockClass": "ClockSource",
    "description": "Discrete time clock source block.",
    "docstringHtml": "<p>Discrete time clock source block.</p>\n<p>Utilizes scheduled events to periodically set\nthe block output to 0 or 1 at discrete times.</p>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>period of the clock</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>clock delay</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>internal scheduled event list</dd>\n</dl>\n</div>\n",
    "params": {
      "T": {
        "type": "integer",
        "default": "1",
        "description": "period of the clock"
      },
      "tau": {
        "type": "integer",
        "default": "0",
        "description": "clock delay"
      }
    },
    "inputs": [],
    "outputs": [
      "out"
    ]
  },
  "WhiteNoise": {
    "blockClass": "WhiteNoise",
    "description": "White noise source with uniform spectral density.",
    "docstringHtml": "<p>White noise source with uniform spectral density. Samples from\ndistribution with 'sampling_rate' and holds noise values constant\nfor time bins (zero-order-hold).</p>\n<p>If no 'sampling_rate' (None) is specified, every simulation timestep\ngets a new noise value. This is the default setting.</p>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>spectral_density <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>noise spectral density</dd>\n<dt>noise <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>internal noise value</dd>\n<dt>sampling_rate <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, None</span></dt>\n<dd>frequency with which the noise is sampled</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>scheduled event for periodic sampling</dd>\n</dl>\n</div>\n",
    "params": {
      "spectral_density": {
        "type": "integer",
        "default": "1",
        "description": "noise spectral density"
      },
      "sampling_rate": {
        "type": "any",
        "default": null,
        "description": "frequency with which the noise is sampled"
      }
    },
    "inputs": [],
    "outputs": [
      "out"
    ]
  },
  "PinkNoise": {
    "blockClass": "PinkNoise",
    "description": "Pink noise (1/f) source using the Voss-McCartney algorithm.",
    "docstringHtml": "<p>Pink noise (1/f) source using the Voss-McCartney algorithm.</p>\n<p>Generates noise with power spectral density inversely proportional to\nfrequency. Samples from distribution with 'sampling_rate' and holds\nnoise values constant for time bins (zero-order-hold).</p>\n<p>The Voss-McCartney algorithm maintains <tt class=\"docutils literal\">num_octaves</tt> independent\nrandom values. At each sample n, octaves are selectively updated based\non the binary representation of n:</p>\n<ul class=\"simple\">\n<li>Octave 0: updated every sample (when n &amp; 1 == 1)</li>\n<li>Octave 1: updated every 2nd sample (when n &amp; 2 == 2)</li>\n<li>Octave 2: updated every 4th sample (when n &amp; 4 == 4)</li>\n<li>Octave k: updated every <span class=\"math\">\\(2^k\\)</span> samples</li>\n</ul>\n<p>The pink noise output is the sum of all octaves, scaled to achieve the\ndesired spectral density:</p>\n<div class=\"math\">\n\\begin{equation*}\ny[n] = \\sqrt{\\frac{S_0}{N \\cdot dt}} \\sum_{k=0}^{N-1} x_k[n]\n\\end{equation*}\n</div>\n<p>where <span class=\"math\">\\(S_0\\)</span> is the spectral density, <span class=\"math\">\\(N\\)</span> is <tt class=\"docutils literal\">num_octaves</tt>,\n<span class=\"math\">\\(dt\\)</span> is the sampling timestep, and <span class=\"math\">\\(x_k[n]\\)</span> are the octave\nvalues (each drawn from <span class=\"math\">\\(\\mathcal{N}(0, 1)\\)</span> when updated).</p>\n<div class=\"section\" id=\"note\">\n<h3>Note</h3>\n<p>If no 'sampling_rate' (None) is specified, every simulation timestep\ngets a new noise value. This is the default setting.</p>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>spectral_density <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>noise spectral density <span class=\"math\">\\(S_0\\)</span></dd>\n<dt>num_octaves <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>number of octaves (levels of randomness), default is 16</dd>\n<dt>sampling_rate <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, None</span></dt>\n<dd>frequency with which the noise is sampled</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>n_samples <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>internal sample counter</dd>\n<dt>octave_values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>internal random numbers for octaves in the Voss-McCartney algorithm</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>scheduled event for periodic sampling</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"references\">\n<h3>References</h3>\n<table class=\"docutils footnote\" frame=\"void\" id=\"footnote-1\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\">[1]</td><td>Voss, R. F., &amp; Clarke, J. (1978). &quot;1/f noise&quot; in music: Music from\n1/f noise. The Journal of the Acoustical Society of America, 63(1),\n258-263.</td></tr>\n</tbody>\n</table>\n</div>\n",
    "params": {
      "spectral_density": {
        "type": "integer",
        "default": "1",
        "description": "noise spectral density :math:`S_0`"
      },
      "num_octaves": {
        "type": "integer",
        "default": "16",
        "description": "number of octaves (levels of randomness), default is 16"
      },
      "sampling_rate": {
        "type": "any",
        "default": null,
        "description": "frequency with which the noise is sampled"
      }
    },
    "inputs": [],
    "outputs": [
      "out"
    ]
  },
  "RandomNumberGenerator": {
    "blockClass": "RandomNumberGenerator",
    "description": "Generates a random output value using `numpy.random.rand`.",
    "docstringHtml": "<p>Generates a random output value using <cite>numpy.random.rand</cite>.</p>\n<p>If no <cite>sampling_rate</cite> (None) is specified, every simulation timestep gets\na random value. Otherwise an internal <cite>Schedule</cite> event is used to periodically\nsample a random value and set the output like a sero-order-hold stage.</p>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>sampling_rate <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, None</span></dt>\n<dd>number of random samples per time unit</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>_sample <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>internal random number state in case that\nno <cite>samplingrate</cite> is provided</dd>\n<dt>Evt <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Schedule</span></dt>\n<dd>internal event that periodically samples a random\nvalue in case <cite>samplingrate</cite> is provided</dd>\n</dl>\n</div>\n",
    "params": {
      "sampling_rate": {
        "type": "any",
        "default": null,
        "description": "number of random samples per time unit"
      }
    },
    "inputs": [],
    "outputs": [
      "out"
    ]
  },
  "Integrator": {
    "blockClass": "Integrator",
    "description": "Integrates the input signal using a numerical integration engine like this:",
    "docstringHtml": "<p>Integrates the input signal using a numerical integration engine like this:</p>\n<div class=\"math\">\n\\begin{equation*}\ny(t) = \\int_0^t u(\\tau) \\ d \\tau\n\\end{equation*}\n</div>\n<p>or in differential form like this:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\begin{eqnarray}\n    \\dot{x}(t) &amp;= u(t) \\\\\n           y(t) &amp;= x(t)\n\\end{eqnarray}\n\\end{equation*}\n</div>\n<p>The Integrator block is inherently MIMO capable, so <cite>u</cite> and <cite>y</cite> can be vectors.</p>\n<div class=\"section\" id=\"example\">\n<h3>Example</h3>\n<p>This is how to initialize the integrator:</p>\n<pre class=\"code python literal-block\">\n#initial value 0.0\ni1 = Integrator()\n\n#initial value 2.5\ni2 = Integrator(2.5)\n</pre>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array</span></dt>\n<dd>initial value of integrator</dd>\n</dl>\n</div>\n",
    "params": {
      "initial_value": {
        "type": "number",
        "default": "0.0",
        "description": "initial value of integrator"
      }
    },
    "inputs": [],
    "outputs": []
  },
  "Differentiator": {
    "blockClass": "Differentiator",
    "description": "Differentiates the input signal (SISO) using a first order transfer function",
    "docstringHtml": "<p>Differentiates the input signal (SISO) using a first order transfer function\nwith a pole at the origin which implements a high pass filter.</p>\n<div class=\"math\">\n\\begin{equation*}\nH_\\mathrm{diff}(s) = \\frac{s}{1 + s / f_\\mathrm{max}}\n\\end{equation*}\n</div>\n<p>The approximation holds for signals up to a frequency of approximately f_max.</p>\n<div class=\"section\" id=\"note\">\n<h3>Note</h3>\n<p>Depending on <cite>f_max</cite>, the resulting system might become stiff or ill conditioned!\nAs a practical choice set <cite>f_max</cite> to 3x the highest expected signal frequency.</p>\n</div>\n<div class=\"section\" id=\"note-1\">\n<h3>Note</h3>\n<p>Since this is an approximation of real differentiation, the approximation will not hold\nif there are high frequency components present in the signal. For example if you have\ndiscontinuities such as steps or squere waves.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h3>Example</h3>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n#cutoff at 1kHz\nD = Differentiator(f_max=1e3)\n</pre>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>f_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>highest expected signal frequency</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for ODE component</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
    "params": {
      "f_max": {
        "type": "number",
        "default": "100.0",
        "description": "highest expected signal frequency"
      }
    },
    "inputs": [],
    "outputs": []
  },
  "Delay": {
    "blockClass": "Delay",
    "description": "Delays the input signal by a time constant 'tau' in seconds",
    "docstringHtml": "<p>Delays the input signal by a time constant 'tau' in seconds\nusing an adaptive rolling buffer.</p>\n<p>Mathematically this block creates a time delay of the input signal like this:</p>\n<div class=\"math\">\n\\begin{equation*}\ny(t) =\n\\begin{cases}\nx(t - \\tau) &amp; , t \\geq \\tau \\\\\n0            &amp; , t &lt; \\tau\n\\end{cases}\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"note\">\n<h3>Note</h3>\n<p>The internal adaptive buffer uses interpolation for the evaluation. This is\nrequired to be compatible with variable step solvers. It has a drawback however.\nThe order of the ode solver used will degrade when this block is used, due to\nthe interpolation.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h3>Example</h3>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n#5 time units delay\nD = Delay(tau=5)\n</pre>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>delay time constant</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>_buffer <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">AdaptiveBuffer</span></dt>\n<dd>internal interpolatable adaptive rolling buffer</dd>\n</dl>\n</div>\n",
    "params": {
      "tau": {
        "type": "number",
        "default": "0.001",
        "description": "delay time constant"
      }
    },
    "inputs": [],
    "outputs": []
  },
  "ODE": {
    "blockClass": "ODE",
    "description": "This block implements an ordinary differential equation (ODE)",
    "docstringHtml": "<p>This block implements an ordinary differential equation (ODE)\ndefined by its right hand side</p>\n<div class=\"math\">\n\\begin{equation*}\n\\begin{eqnarray}\n    \\dot{x}(t) =&amp; \\mathrm{func}(x(t), u(t), t) \\\\\n           y(t) =&amp; x(t)\n\\end{eqnarray}\n\\end{equation*}\n</div>\n<p>with inhomogenity (input) <cite>u</cite> and state vector <cite>x</cite>. The function\ncan be nonlinear and the ODE can be of arbitrary order.\nThe block utilizes the integration engine to solve the ODE\nby integrating the <cite>func</cite>, which is the right hand side function.</p>\n<div class=\"section\" id=\"example\">\n<h3>Example</h3>\n<p>For example a linear 1st order ODE:</p>\n<pre class=\"code python literal-block\">\node = ODE(lambda x, u, t: -x)\n</pre>\n<p>Or something more complex like the <cite>Van der Pol</cite> system, where it makes\nsense to also specify the jacobian, which improves convergence for\nimplicit solvers but is not needed in most cases:</p>\n<pre class=\"code python literal-block\">\nimport numpy as np\n\n#initial condition\nx0 = np.array([2, 0])\n\n#van der Pol parameter\nmu = 1000\n\ndef func(x, u, t):\n    return np.array([x[1], mu*(1 - x[0]**2)*x[1] - x[0]])\n\n#analytical jacobian (optional)\ndef jac(x, u, t):\n    return np.array(\n        [[0                , 1               ],\n         [-mu*2*x[0]*x[1]-1, mu*(1 - x[0]**2)]]\n         )\n\n#finally the block\nvdp = ODE(func, x0, jac)\n</pre>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>right hand side function of ODE</dd>\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>initial state / initial condition</dd>\n<dt>jac <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable, None</span></dt>\n<dd>jacobian of 'func' or 'None'</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for ODE right hand side 'func'</dd>\n</dl>\n</div>\n",
    "params": {
      "func": {
        "type": "callable",
        "default": null,
        "description": "right hand side function of ODE"
      },
      "initial_value": {
        "type": "number",
        "default": "0.0",
        "description": "initial state / initial condition"
      },
      "jac": {
        "type": "any",
        "default": null,
        "description": "jacobian of 'func' or 'None'"
      }
    },
    "inputs": [],
    "outputs": []
  },
  "DynamicalSystem": {
    "blockClass": "DynamicalSystem",
    "description": "This block implements a nonlinear dynamical system / nonlinear state space model.",
    "docstringHtml": "<p>This block implements a nonlinear dynamical system / nonlinear state space model.</p>\n<p>Its basically the same as the <cite>ODE</cite> block with the addition of an output equation\nthat takes the state, input and time as arguments:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\begin{eqnarray}\n    \\dot{x}(t) =&amp; \\mathrm{func}_\\mathrm{dyn}(x(t), u(t), t) \\\\\n           y(t) =&amp; \\mathrm{func}_\\mathrm{alg}(x(t), u(t), t)\n\\end{eqnarray}\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>func_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>right hand side function of ode-part of the system</dd>\n<dt>func_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>output function of the system</dd>\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>initial state / initial condition</dd>\n<dt>jac_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable | None</span></dt>\n<dd>optional jacobian of <cite>func_dyn</cite> to improve convergence\nfor implicit ode solvers</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for <cite>func_dyn</cite></dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for <cite>func_alg</cite></dd>\n</dl>\n</div>\n",
    "params": {
      "func_dyn": {
        "type": "callable",
        "default": null,
        "description": "right hand side function of ode-part of the system"
      },
      "func_alg": {
        "type": "callable",
        "default": null,
        "description": "output function of the system"
      },
      "initial_value": {
        "type": "number",
        "default": "0.0",
        "description": "initial state / initial condition"
      },
      "jac_dyn": {
        "type": "any",
        "default": null,
        "description": "optional jacobian of `func_dyn` to improve convergence for implicit ode solvers"
      }
    },
    "inputs": [],
    "outputs": []
  },
  "StateSpace": {
    "blockClass": "StateSpace",
    "description": "This block defines a linear time invariant (LTI) multi input multi output (MIMO)",
    "docstringHtml": "<p>This block defines a linear time invariant (LTI) multi input multi output (MIMO)\nstate space model with the structure</p>\n<div class=\"math\">\n\\begin{equation*}\n\\begin{eqnarray}\n    \\dot{x} &amp;= \\mathbf{A} x + \\mathbf{B} u \\\\\n           y &amp;= \\mathbf{C} x + \\mathbf{D} u\n\\end{eqnarray}\n\\end{equation*}\n</div>\n<p>where <cite>A</cite>, <cite>B</cite>, <cite>C</cite> and <cite>D</cite> are the state space matrices, <cite>x</cite> is the state,\n<cite>u</cite> the input and <cite>y</cite> the output vector.</p>\n<div class=\"section\" id=\"example\">\n<h3>Example</h3>\n<p>A SISO state space block with two internal states can be initialized\nlike this:</p>\n<pre class=\"code python literal-block\">\nS = StateSpace(\n    A=-np.eye(2),\n    B=np.ones((2, 1)),\n    C=np.ones((1, 2)),\n    D=1.0\n    )\n</pre>\n<p>and a MIMO (2 in, 2 out) state space block with three internal states\ncan be initialized like this:</p>\n<pre class=\"code python literal-block\">\nS = StateSpace(\n    A=-np.eye(3),\n    B=np.ones((3, 2)),\n    C=np.ones((2, 3)),\n    D=np.ones((2, 2))\n    )\n</pre>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>A, B, C, D <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>real valued state space matrices</dd>\n<dt>initial_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like, None</span></dt>\n<dd>initial state / initial condition</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for state equation</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal algebraic operator for mapping to outputs</dd>\n</dl>\n</div>\n",
    "params": {
      "A": {
        "type": "number",
        "default": "-1.0",
        "description": ""
      },
      "B": {
        "type": "number",
        "default": "1.0",
        "description": ""
      },
      "C": {
        "type": "number",
        "default": "-1.0",
        "description": ""
      },
      "D": {
        "type": "number",
        "default": "1.0",
        "description": "real valued state space matrices"
      },
      "initial_value": {
        "type": "any",
        "default": null,
        "description": "initial state / initial condition"
      }
    },
    "inputs": [],
    "outputs": []
  },
  "PID": {
    "blockClass": "PID",
    "description": "Proportional-Integral-Differntiation (PID) controller.",
    "docstringHtml": "<p>Proportional-Integral-Differntiation (PID) controller.</p>\n<p>The transfer function is defined as</p>\n<div class=\"math\">\n\\begin{equation*}\nH_\\mathrm{diff}(s) = K_p + K_i \\frac{1}{s} + K_d \\frac{s}{1 + s / f_\\mathrm{max}}\n\\end{equation*}\n</div>\n<p>where the differentiation is approximated by a high pass filter that holds\nfor signals up to a frequency of approximately <cite>f_max</cite>.</p>\n<div class=\"section\" id=\"note\">\n<h3>Note</h3>\n<p>Depending on <cite>f_max</cite>, the resulting system might become stiff or ill conditioned!\nAs a practical choice set <cite>f_max</cite> to 3x the highest expected signal frequency.\nSince this block uses an approximation of real differentiation, the approximation will\nnot hold if there are high frequency components present in the signal. For example if\nyou have discontinuities such as steps or square waves.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h3>Example</h3>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n#cutoff at 1kHz\npid = PID(Kp=2, Ki=0.5, Kd=0.1, f_max=1e3)\n</pre>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>Kp <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>poroportional controller coefficient</dd>\n<dt>Ki <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integral controller coefficient</dd>\n<dt>Kd <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>differentiator controller coefficient</dd>\n<dt>f_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>highest expected signal frequency</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for ODE component</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
    "params": {
      "Kp": {
        "type": "integer",
        "default": "0",
        "description": "poroportional controller coefficient"
      },
      "Ki": {
        "type": "integer",
        "default": "0",
        "description": "integral controller coefficient"
      },
      "Kd": {
        "type": "integer",
        "default": "0",
        "description": "differentiator controller coefficient"
      },
      "f_max": {
        "type": "integer",
        "default": "100",
        "description": "highest expected signal frequency"
      }
    },
    "inputs": [
      "in"
    ],
    "outputs": [
      "out"
    ]
  },
  "AntiWindupPID": {
    "blockClass": "AntiWindupPID",
    "description": "Proportional-Integral-Differntiation (PID) controller with tracking",
    "docstringHtml": "<p>Proportional-Integral-Differntiation (PID) controller with tracking\nanti-windup mechanism (back-calculation).</p>\n<p>Anti-windup mechanisms are needed when the magnitude of the control signal\nfrom the PID controller is limited by some real world saturation. In these cases,\nthe integrator will continue to acumulate the control error and &quot;wind itself up&quot;.\nOnce the setpoint is reached, this can result in significant overshoots. This\nimplementation adds a conditional feedback term to the internal integrator that\n&quot;unwinds&quot; it when the PID output crosses some limits. This is pretty much a\ndeadzone feedback element for the integrator.</p>\n<p>Mathematically, this block implements the following set of ODEs</p>\n<div class=\"math\">\n\\begin{equation*}\n\\begin{eqnarray}\n\\dot{x}_1 =&amp; f_\\mathrm{max} (u - x_1) \\\\\n\\dot{x}_2 =&amp; u - w \\\\\n\\end{eqnarray}\n\\end{equation*}\n</div>\n<p>with the anti-windup feedback (depending on the pid output)</p>\n<div class=\"math\">\n\\begin{equation*}\nw = K_s (y - \\min(\\max(y, y_\\mathrm{min}), y_\\mathrm{max}))\n\\end{equation*}\n</div>\n<p>and the output itself</p>\n<div class=\"math\">\n\\begin{equation*}\ny = K_p u - K_d f_\\mathrm{max} x_1 + K_i x_2\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"note\">\n<h3>Note</h3>\n<p>Depending on <cite>f_max</cite>, the resulting system might become stiff or ill conditioned!\nAs a practical choice set <cite>f_max</cite> to 3x the highest expected signal frequency.\nSince this block uses an approximation of real differentiation, the approximation will\nnot hold if there are high frequency components present in the signal. For example if\nyou have discontinuities such as steps or squere waves.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h3>Example</h3>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n#cutoff at 1kHz, windup limits at [-5, 5]\npid = AntiWindupPID(Kp=2, Ki=0.5, Kd=0.1, f_max=1e3, limits=[-5, 5])\n</pre>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>Kp <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>poroportional controller coefficient</dd>\n<dt>Ki <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>integral controller coefficient</dd>\n<dt>Kd <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>differentiator controller coefficient</dd>\n<dt>f_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>highest expected signal frequency</dd>\n<dt>Ks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>feedback term for back calculation for anti-windup control of integrator</dd>\n<dt>limits <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like[float]</span></dt>\n<dd>lower and upper limit for PID output that triggers anti-windup of integrator</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_dyn <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal dynamic operator for ODE component</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">DynamicOperator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
    "params": {
      "Kp": {
        "type": "integer",
        "default": "0",
        "description": "poroportional controller coefficient"
      },
      "Ki": {
        "type": "integer",
        "default": "0",
        "description": "integral controller coefficient"
      },
      "Kd": {
        "type": "integer",
        "default": "0",
        "description": "differentiator controller coefficient"
      },
      "f_max": {
        "type": "integer",
        "default": "100",
        "description": "highest expected signal frequency"
      },
      "Ks": {
        "type": "integer",
        "default": "10",
        "description": "feedback term for back calculation for anti-windup control of integrator"
      },
      "limits": {
        "type": "array",
        "default": "[-10, 10]",
        "description": "lower and upper limit for PID output that triggers anti-windup of integrator"
      }
    },
    "inputs": [
      "in"
    ],
    "outputs": [
      "out"
    ]
  },
  "TransferFunctionNumDen": {
    "blockClass": "TransferFunctionNumDen",
    "description": "This block defines a LTI (SISO) transfer function.",
    "docstringHtml": "<p>This block defines a LTI (SISO) transfer function.</p>\n<p>The transfer function is defined in polynomial (numerator-denominator) form</p>\n<div class=\"math\">\n\\begin{equation*}\n\\mathbf{H}(s) = \\frac{b_n + b_{n-1} s + \\dots + b_{0} s^n}{a_m + a_{m-1} s + \\dots + a_{0} s^m}\n\\end{equation*}\n</div>\n<p>where <cite>Num</cite> is the list of numerator polynomial coefficients and <cite>Den</cite> the\nlist of denominator coefficients.</p>\n<p>Upon initialization, the state space realization of the transfer function is\ncomputed using <cite>scipy.signal.TransferFunction(Num, Den).to_ss()</cite>.</p>\n<p>The resulting state space model of the form</p>\n<div class=\"math\">\n\\begin{equation*}\n\\begin{eqnarray}\n    \\dot{x} &amp;= \\mathbf{A} x + \\mathbf{B} u \\\\\n           y &amp;= \\mathbf{C} x + \\mathbf{D} u\n\\end{eqnarray}\n\\end{equation*}\n</div>\n<p>is handled the same as the 'StateSpace' block, where <cite>A</cite>, <cite>B</cite>, <cite>C</cite> and <cite>D</cite>\nare the state space matrices, <cite>x</cite> is the internal state, <cite>u</cite> the input and\n<cite>y</cite> the output vector.</p>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>Num <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>numerator polynomial coefficients</dd>\n<dt>Den <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>denominator polynomial coefficients</dd>\n</dl>\n</div>\n",
    "params": {
      "Num": {
        "type": "array",
        "default": "[1]",
        "description": "numerator polynomial coefficients"
      },
      "Den": {
        "type": "array",
        "default": "[1, 1]",
        "description": "denominator polynomial coefficients"
      }
    },
    "inputs": [],
    "outputs": []
  },
  "TransferFunctionZPG": {
    "blockClass": "TransferFunctionZPG",
    "description": "This block defines a LTI (SISO) transfer function.",
    "docstringHtml": "<p>This block defines a LTI (SISO) transfer function.</p>\n<p>The transfer function is defined in zeros-poles-gain (ZPG) form</p>\n<div class=\"math\">\n\\begin{equation*}\n\\mathbf{H}(s) = k \\frac{(s - z_1)(s - z_2)\\cdots(s - z_m)}{(s - p_1)(s - p_2)\\cdots(s - p_n)}\n\\end{equation*}\n</div>\n<p>where <cite>Zeros</cite> are the scalar (possibly complex conjugate) zeros of the\ntransfer function, and <cite>Poles</cite> are the poles (denominator zeros) of the\ntransfer function. <cite>Gain</cite> is the scalar factor <cite>k</cite>.</p>\n<p>Upon initialization, the state space realization of the transfer function is\ncomputed using <cite>scipy.signal.ZerosPolesGain(Zeros, Poles, Gain).to_ss()</cite>.</p>\n<p>The resulting state space model of the form</p>\n<div class=\"math\">\n\\begin{equation*}\n\\begin{eqnarray}\n    \\dot{x} &amp;= \\mathbf{A} x + \\mathbf{B} u \\\\\n           y &amp;= \\mathbf{C} x + \\mathbf{D} u\n\\end{eqnarray}\n\\end{equation*}\n</div>\n<p>is handled the same as the 'StateSpace' block, where <cite>A</cite>, <cite>B</cite>, <cite>C</cite> and <cite>D</cite>\nare the state space matrices, <cite>x</cite> is the internal state, <cite>u</cite> the input and\n<cite>y</cite> the output vector.</p>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>Poles <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>transfer function poles</dd>\n<dt>Zeros <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>transfer function zeros</dd>\n<dt>Gain <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>gain term of transfer function</dd>\n</dl>\n</div>\n",
    "params": {
      "Zeros": {
        "type": "array",
        "default": "[]",
        "description": "transfer function zeros"
      },
      "Poles": {
        "type": "array",
        "default": "[-1]",
        "description": "transfer function poles"
      },
      "Gain": {
        "type": "number",
        "default": "1.0",
        "description": "gain term of transfer function"
      }
    },
    "inputs": [],
    "outputs": []
  },
  "ButterworthLowpassFilter": {
    "blockClass": "ButterworthLowpassFilter",
    "description": "Direct implementation of a low pass butterworth filter block.",
    "docstringHtml": "<p>Direct implementation of a low pass butterworth filter block.</p>\n<p>Follows the same structure as the 'StateSpace' block in the\n'pathsim.blocks' module. The numerator and denominator of the\nfilter transfer function are generated and then the transfer\nfunction is realized as a state space model.</p>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>Fc <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>corner frequency of the filter in [Hz]</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>filter order</dd>\n</dl>\n</div>\n",
    "params": {
      "Fc": {
        "type": "integer",
        "default": "100",
        "description": "corner frequency of the filter in [Hz]"
      },
      "n": {
        "type": "integer",
        "default": "2",
        "description": "filter order"
      }
    },
    "inputs": [
      "in"
    ],
    "outputs": [
      "out"
    ]
  },
  "ButterworthHighpassFilter": {
    "blockClass": "ButterworthHighpassFilter",
    "description": "Direct implementation of a high pass butterworth filter block.",
    "docstringHtml": "<p>Direct implementation of a high pass butterworth filter block.</p>\n<p>Follows the same structure as the 'StateSpace' block in the\n'pathsim.blocks' module. The numerator and denominator of the\nfilter transfer function are generated and then the transfer\nfunction is realized as a state space model.</p>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>Fc <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>corner frequency of the filter in [Hz]</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>filter order</dd>\n</dl>\n</div>\n",
    "params": {
      "Fc": {
        "type": "integer",
        "default": "100",
        "description": "corner frequency of the filter in [Hz]"
      },
      "n": {
        "type": "integer",
        "default": "2",
        "description": "filter order"
      }
    },
    "inputs": [
      "in"
    ],
    "outputs": [
      "out"
    ]
  },
  "ButterworthBandpassFilter": {
    "blockClass": "ButterworthBandpassFilter",
    "description": "Direct implementation of a bandpass butterworth filter block.",
    "docstringHtml": "<p>Direct implementation of a bandpass butterworth filter block.</p>\n<p>Follows the same structure as the 'StateSpace' block in the\n'pathsim.blocks' module. The numerator and denominator of the\nfilter transfer function are generated and then the transfer\nfunction is realized as a state space model.</p>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>Fc <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>corner frequencies (left, right) of the filter in [Hz]</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>filter order</dd>\n</dl>\n</div>\n",
    "params": {
      "Fc": {
        "type": "array",
        "default": "[50, 100]",
        "description": "corner frequencies (left, right) of the filter in [Hz]"
      },
      "n": {
        "type": "integer",
        "default": "2",
        "description": "filter order"
      }
    },
    "inputs": [
      "in"
    ],
    "outputs": [
      "out"
    ]
  },
  "ButterworthBandstopFilter": {
    "blockClass": "ButterworthBandstopFilter",
    "description": "Direct implementation of a bandstop butterworth filter block.",
    "docstringHtml": "<p>Direct implementation of a bandstop butterworth filter block.</p>\n<p>Follows the same structure as the 'StateSpace' block in the\n'pathsim.blocks' module. The numerator and denominator of the\nfilter transfer function are generated and then the transfer\nfunction is realized as a state space model.</p>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>Fc <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">tuple[float], list[float]</span></dt>\n<dd>corner frequencies (left, right) of the filter in [Hz]</dd>\n<dt>n <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>filter order</dd>\n</dl>\n</div>\n",
    "params": {
      "Fc": {
        "type": "array",
        "default": "[50, 100]",
        "description": "corner frequencies (left, right) of the filter in [Hz]"
      },
      "n": {
        "type": "integer",
        "default": "2",
        "description": "filter order"
      }
    },
    "inputs": [
      "in"
    ],
    "outputs": [
      "out"
    ]
  },
  "Adder": {
    "blockClass": "Adder",
    "description": "Summs / adds up all input signals to a single output signal (MISO)",
    "docstringHtml": "<p>Summs / adds up all input signals to a single output signal (MISO)</p>\n<p>This is how it works in the default case</p>\n<div class=\"math\">\n\\begin{equation*}\ny(t) = \\sum_i u_i(t)\n\\end{equation*}\n</div>\n<p>and like this when additional operations are defined</p>\n<div class=\"math\">\n\\begin{equation*}\ny(t) = \\sum_i \\mathrm{op}_i \\cdot u_i(t)\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"example\">\n<h3>Example</h3>\n<p>This is the default initialization that just adds up all the inputs:</p>\n<pre class=\"code python literal-block\">\nA = Adder()\n</pre>\n<p>and this is the initialization with specific operations that subtracts\nthe second from first input and neglects all others:</p>\n<pre class=\"code python literal-block\">\nA = Adder('+-')\n</pre>\n</div>\n<div class=\"section\" id=\"note\">\n<h3>Note</h3>\n<p>This block is purely algebraic and its operation (<cite>op_alg</cite>) will be called\nmultiple times per timestep, each time when <cite>Simulation._update(t)</cite> is\ncalled in the global simulation loop.</p>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>operations <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">str, optional</span></dt>\n<dd>optional string of operations to be applied before\nsummation, i.e. '+-' will compute the difference,\n'None' will just perform regular sum</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>_ops <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">dict</span></dt>\n<dd>dict that maps string operations to numerical</dd>\n<dt>_ops_array <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>operations converted to array</dd>\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
    "params": {
      "operations": {
        "type": "any",
        "default": null,
        "description": "optional string of operations to be applied before summation, i.e. '+-' will compute the difference, 'None' will just perform regular sum"
      }
    },
    "inputs": [],
    "outputs": [
      "out"
    ]
  },
  "Multiplier": {
    "blockClass": "Multiplier",
    "description": "Multiplies all signals from all input ports (MISO).",
    "docstringHtml": "<p>Multiplies all signals from all input ports (MISO).</p>\n<div class=\"math\">\n\\begin{equation*}\ny(t) = \\prod_i u_i(t)\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"note\">\n<h3>Note</h3>\n<p>This block is purely algebraic and its operation (<cite>op_alg</cite>) will be called\nmultiple times per timestep, each time when <cite>Simulation._update(t)</cite> is\ncalled in the global simulation loop.</p>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator that wraps 'prod'</dd>\n</dl>\n</div>\n",
    "params": {},
    "inputs": [],
    "outputs": [
      "out"
    ]
  },
  "Amplifier": {
    "blockClass": "Amplifier",
    "description": "Amplifies the input signal by",
    "docstringHtml": "<p>Amplifies the input signal by\nmultiplication with a constant gain term like this:</p>\n<div class=\"math\">\n\\begin{equation*}\ny(t) = \\mathrm{gain} \\cdot u(t)\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"note\">\n<h3>Note</h3>\n<p>This block is purely algebraic and its operation (<cite>op_alg</cite>) will be called\nmultiple times per timestep, each time when <cite>Simulation._update(t)</cite> is\ncalled in the global simulation loop.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h3>Example</h3>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n#amplification by factor 5\nA = Amplifier(gain=5)\n</pre>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>gain <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>amplifier gain</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
    "params": {
      "gain": {
        "type": "number",
        "default": "1.0",
        "description": "amplifier gain"
      }
    },
    "inputs": [],
    "outputs": []
  },
  "Function": {
    "blockClass": "Function",
    "description": "Arbitrary MIMO function block, defined by a callable object,",
    "docstringHtml": "<p>Arbitrary MIMO function block, defined by a callable object,\ni.e. function or <cite>lambda</cite> expression.</p>\n<p>The function can have multiple arguments that are then provided\nby the input channels of the function block.</p>\n<p>Form multi input, the function has to specify multiple arguments\nand for multi output, the aoutputs have to be provided as a\ntuple or list.</p>\n<p>In the context of the global system, this block implements algebraic\ncomponents of the global system ODE/DAE.</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\mathrm{func}(\\vec{u})\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"note\">\n<h3>Note</h3>\n<p>This block is purely algebraic and its operation (<cite>op_alg</cite>) will be called\nmultiple times per timestep, each time when <cite>Simulation._update(t)</cite> is\ncalled in the global simulation loop.\nTherefore <cite>func</cite> must be purely algebraic and not introduce states,\ndelay, etc. For interfacing with external stateful APIs, use the\n<cite>Wrapper</cite> block.</p>\n</div>\n<div class=\"section\" id=\"note-1\">\n<h3>Note</h3>\n<p>If the outputs are provided as a single numpy array, they are\nconsidered a single output. For MIMO, output has to be tuple.</p>\n</div>\n<div class=\"section\" id=\"example\">\n<h3>Example</h3>\n<p>consider the function:</p>\n<pre class=\"code python literal-block\">\nfrom pathsim.blocks import Function\n\ndef f(a, b, c):\n    return a**2, a*b, b/c\n\nfn = Function(f)\n</pre>\n<p>then, when the block is uldated, the input channels of the block are\nassigned to the function arguments following this scheme:</p>\n<pre class=\"code literal-block\">\ninputs[0] -&gt; a\ninputs[1] -&gt; b\ninputs[2] -&gt; c\n</pre>\n<p>and the function outputs are assigned to the\noutput channels of the block in the same way:</p>\n<pre class=\"code literal-block\">\na**2 -&gt; outputs[0]\na*b  -&gt; outputs[1]\nb/c  -&gt; outputs[2]\n</pre>\n<p>Because the <cite>Function</cite> block only has a single argument, it can be\nused to decorate a function and make it a <cite>PathSim</cite> block. This might\nbe handy in some cases to keep definitions concise and localized\nin the code:</p>\n<pre class=\"code python literal-block\">\nfrom pathsim.blocks import Function\n\n#does the same as the definition above\n\n&#64;Function\ndef fn(a, b, c):\n    return a**2, a*b, b/c\n\n#'fn' is now a PathSim block\n</pre>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>func <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">callable</span></dt>\n<dd>MIMO function that defines algebraic block IO behaviour, signature <cite>func(*tuple)</cite></dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator that wraps <cite>func</cite></dd>\n</dl>\n</div>\n",
    "params": {
      "func": {
        "type": "callable",
        "default": null,
        "description": "MIMO function that defines algebraic block IO behaviour, signature `func(*tuple)`"
      }
    },
    "inputs": [],
    "outputs": []
  },
  "Sin": {
    "blockClass": "Sin",
    "description": "Sine operator block.",
    "docstringHtml": "<p>Sine operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\sin(\\vec{u})\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
    "params": {},
    "inputs": [],
    "outputs": []
  },
  "Cos": {
    "blockClass": "Cos",
    "description": "Cosine operator block.",
    "docstringHtml": "<p>Cosine operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\cos(\\vec{u})\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
    "params": {},
    "inputs": [],
    "outputs": []
  },
  "Tan": {
    "blockClass": "Tan",
    "description": "Tangent operator block.",
    "docstringHtml": "<p>Tangent operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\tan(\\vec{u})\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
    "params": {},
    "inputs": [],
    "outputs": []
  },
  "Tanh": {
    "blockClass": "Tanh",
    "description": "Hyperbolic tangent operator block.",
    "docstringHtml": "<p>Hyperbolic tangent operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\tanh(\\vec{u})\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
    "params": {},
    "inputs": [],
    "outputs": []
  },
  "Abs": {
    "blockClass": "Abs",
    "description": "Absolute value operator block.",
    "docstringHtml": "<p>Absolute value operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\vert| \\vec{u} \\vert|\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
    "params": {},
    "inputs": [],
    "outputs": []
  },
  "Sqrt": {
    "blockClass": "Sqrt",
    "description": "Square root operator block.",
    "docstringHtml": "<p>Square root operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\sqrt{|\\vec{u}|}\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
    "params": {},
    "inputs": [],
    "outputs": []
  },
  "Exp": {
    "blockClass": "Exp",
    "description": "Exponential operator block.",
    "docstringHtml": "<p>Exponential operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = e^{\\vec{u}}\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
    "params": {},
    "inputs": [],
    "outputs": []
  },
  "Log": {
    "blockClass": "Log",
    "description": "Natural logarithm operator block.",
    "docstringHtml": "<p>Natural logarithm operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\ln(\\vec{u})\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
    "params": {},
    "inputs": [],
    "outputs": []
  },
  "Log10": {
    "blockClass": "Log10",
    "description": "Base-10 logarithm operator block.",
    "docstringHtml": "<p>Base-10 logarithm operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\log_{10}(\\vec{u})\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
    "params": {},
    "inputs": [],
    "outputs": []
  },
  "Mod": {
    "blockClass": "Mod",
    "description": "Modulo operator block.",
    "docstringHtml": "<p>Modulo operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\vec{u} \\bmod m\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"note\">\n<h3>Note</h3>\n<p>modulo is not differentiable at discontinuities</p>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>modulus <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>modulus value</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
    "params": {
      "modulus": {
        "type": "number",
        "default": "1.0",
        "description": "modulus value Attributes ----------"
      }
    },
    "inputs": [],
    "outputs": []
  },
  "Clip": {
    "blockClass": "Clip",
    "description": "Clipping/saturation operator block.",
    "docstringHtml": "<p>Clipping/saturation operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\text{clip}(\\vec{u}, u_{min}, u_{max})\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>min_val <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array_like</span></dt>\n<dd>minimum clipping value</dd>\n<dt>max_val <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array_like</span></dt>\n<dd>maximum clipping value</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
    "params": {
      "min_val": {
        "type": "number",
        "default": "-1.0",
        "description": "minimum clipping value"
      },
      "max_val": {
        "type": "number",
        "default": "1.0",
        "description": "maximum clipping value Attributes ----------"
      }
    },
    "inputs": [],
    "outputs": []
  },
  "Pow": {
    "blockClass": "Pow",
    "description": "Raise to power operator block.",
    "docstringHtml": "<p>Raise to power operator block.</p>\n<p>This block supports vector inputs. This is the operation it does:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\vec{y} = \\vec{u}^{p}\n\\end{equation*}\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>exponent <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, array_like</span></dt>\n<dd>exponent to raise the input to the power of</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>op_alg <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Operator</span></dt>\n<dd>internal algebraic operator</dd>\n</dl>\n</div>\n",
    "params": {
      "exponent": {
        "type": "integer",
        "default": "2",
        "description": "exponent to raise the input to the power of Attributes ----------"
      }
    },
    "inputs": [],
    "outputs": []
  },
  "Switch": {
    "blockClass": "Switch",
    "description": "Switch block that selects between its inputs and copies",
    "docstringHtml": "<p>Switch block that selects between its inputs and copies\none of them to the output.</p>\n<div class=\"section\" id=\"example\">\n<h3>Example</h3>\n<p>The block is initialized like this:</p>\n<pre class=\"code python literal-block\">\n#default None -&gt; no passthrough\ns1 = Switch()\n\n#selecting port 2 as passthrough\ns2 = Switch(2)\n\n#change the state of the switch to port 3\ns2.select(3)\n</pre>\n<p>Sets block output depending on <cite>self.state</cite> like this:</p>\n<pre class=\"code literal-block\">\nstate == None -&gt; outputs[0] = 0\n\nstate == 0 -&gt; outputs[0] = inputs[0]\n\nstate == 1 -&gt; outputs[0] = inputs[1]\n\nstate == 2 -&gt; outputs[0] = inputs[2]\n\n...\n</pre>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>state <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, None</span></dt>\n<dd>state of the switch</dd>\n</dl>\n</div>\n",
    "params": {
      "state": {
        "type": "any",
        "default": null,
        "description": "state of the switch"
      }
    },
    "inputs": [],
    "outputs": []
  },
  "LUT": {
    "blockClass": "LUT",
    "description": "N-dimensional lookup table with linear interpolation functionality.",
    "docstringHtml": "<p>N-dimensional lookup table with linear interpolation functionality.</p>\n<p>This class implements a multi-dimensional lookup table that uses scipy's\nLinearNDInterpolator <a class=\"footnote-reference\" href=\"#scipy\" id=\"footnote-reference-1\">[1]</a> for piecewise linear interpolation in N-dimensional\nspace. The interpolation is based on Delaunay triangulation of the input points,\nproviding smooth linear interpolation between data points. For points outside\nthe convex hull of the input data, the interpolator returns NaN values.</p>\n<p>The LUT acts as a Function block.</p>\n<div class=\"section\" id=\"references\">\n<h3>References</h3>\n<table class=\"docutils footnote\" frame=\"void\" id=\"scipy\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\"><a class=\"fn-backref\" href=\"#footnote-reference-1\">[1]</a></td><td><a class=\"reference external\" href=\"https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.LinearNDInterpolator.html\">https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.LinearNDInterpolator.html</a></td></tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>points <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like of shape (n, ndim)</span></dt>\n<dd>2-D array of data point coordinates where n is the number of points\nand ndim is the dimensionality of the space. Each row represents a\nsingle data point in ndim-dimensional space.</dd>\n<dt>values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like of shape (n,) or (n, m)</span></dt>\n<dd>N-D array of data values at the corresponding points. If 1-D, represents\nscalar values at each point. If 2-D, each column represents a different\noutput dimension (m output values per input point).</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>points <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Stored array of input point coordinates.</dd>\n<dt>values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Stored array of output values at each point.</dd>\n<dt>inter <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">scipy.interpolate.LinearNDInterpolator</span></dt>\n<dd>The scipy linear interpolator object used for interpolation.</dd>\n</dl>\n</div>\n",
    "params": {
      "points": {
        "type": "any",
        "default": null,
        "description": "2-D array of data point coordinates where n is the number of points and ndim is the dimensionality of the space. Each row represents a single data point in ndim-dimensional space."
      },
      "values": {
        "type": "any",
        "default": null,
        "description": "N-D array of data values at the corresponding points. If 1-D, represents scalar values at each point. If 2-D, each column represents a different output dimension (m output values per input point)."
      }
    },
    "inputs": [],
    "outputs": []
  },
  "LUT1D": {
    "blockClass": "LUT1D",
    "description": "One-dimensional lookup table with linear interpolation functionality.",
    "docstringHtml": "<p>One-dimensional lookup table with linear interpolation functionality.</p>\n<p>This class implements a 1-dimensional lookup table that uses scipy's interp1d <a class=\"footnote-reference\" href=\"#scipy\" id=\"footnote-reference-1\">[1]</a>\nfor piecewise linear interpolation along a single axis. The interpolation\nprovides linear interpolation between adjacent data points and supports\nextrapolation beyond the input data range using the 'extrapolate' fill mode.</p>\n<p>The LUT1D acts as a Function block.</p>\n<div class=\"section\" id=\"references\">\n<h3>References</h3>\n<table class=\"docutils footnote\" frame=\"void\" id=\"scipy\" rules=\"none\">\n<colgroup><col class=\"label\" /><col /></colgroup>\n<tbody valign=\"top\">\n<tr><td class=\"label\"><a class=\"fn-backref\" href=\"#footnote-reference-1\">[1]</a></td><td><a class=\"reference external\" href=\"https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.interp1d.html\">https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.interp1d.html</a></td></tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>points <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like of shape (n,)</span></dt>\n<dd>1-D array of monotonically increasing data point coordinates where n\nis the number of points. These represent the independent variable values\nat which the dependent values are known.</dd>\n<dt>values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like of shape (n,) or (n, m)</span></dt>\n<dd>1-D or 2-D array of data values at the corresponding points. If 1-D,\nrepresents scalar values at each point. If 2-D with shape (n, m),\neach column represents a different output dimension, allowing the\nlookup table to return m-dimensional vectors.</dd>\n<dt>fill_value <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float or str, optional</span></dt>\n<dd>The value to use for points outside the interpolation range. If &quot;extrapolate&quot;,\nthe interpolator will use linear extrapolation. Default is &quot;extrapolate&quot;.\nSee <a class=\"reference external\" href=\"https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.interp1d.html\">https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.interp1d.html</a> for more details</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>points <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Flattened array of input point coordinates, stored as 1-D array.</dd>\n<dt>values <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ndarray</span></dt>\n<dd>Stored array of output values at each point, preserving original shape.</dd>\n<dt>inter <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">scipy.interpolate.interp1d</span></dt>\n<dd>The scipy 1D interpolator object used for linear interpolation with\nextrapolation enabled beyond the data range.</dd>\n</dl>\n</div>\n",
    "params": {
      "points": {
        "type": "any",
        "default": null,
        "description": "1-D array of monotonically increasing data point coordinates where n is the number of points. These represent the independent variable values at which the dependent values are known."
      },
      "values": {
        "type": "any",
        "default": null,
        "description": "1-D or 2-D array of data values at the corresponding points. If 1-D, represents scalar values at each point. If 2-D with shape (n, m), each column represents a different output dimension, allowing the lookup table to return m-dimensional vectors."
      },
      "fill_value": {
        "type": "string",
        "default": "\"extrapolate\"",
        "description": "The value to use for points outside the interpolation range. If \"extrapolate\", the interpolator will use linear extrapolation. Default is \"extrapolate\". See https://docs.scipy.org/doc/scipy-1.16.1/reference/generated/scipy.interpolate.interp1d.html for more details"
      }
    },
    "inputs": [],
    "outputs": []
  },
  "SampleHold": {
    "blockClass": "SampleHold",
    "description": "Sample and hold stage that samples the inputs",
    "docstringHtml": "<p>Sample and hold stage that samples the inputs\nperiodically using scheduled events and produces\nthem at the output.</p>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>sampling period</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>delay</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>internal scheduled event for periodic sampling</dd>\n</dl>\n</div>\n",
    "params": {
      "T": {
        "type": "integer",
        "default": "1",
        "description": "sampling period"
      },
      "tau": {
        "type": "integer",
        "default": "0",
        "description": "delay Attributes ----------"
      }
    },
    "inputs": [],
    "outputs": []
  },
  "FIR": {
    "blockClass": "FIR",
    "description": "Models a discrete-time Finite-Impulse-Response (FIR) filter.",
    "docstringHtml": "<p>Models a discrete-time Finite-Impulse-Response (FIR) filter.</p>\n<p>This block applies an FIR filter to an input signal sampled periodically.\nThe output at each sample time is a weighted sum of the current and a finite number\nof past input samples. The operation is triggered by a scheduled event.</p>\n<p>Functionality:</p>\n<div class=\"math\">\n\\begin{equation*}\ny[n] = b[0] x[n] + b[1] x[n-1] + \\dots + b[N] x[n-N]\n\\end{equation*}\n</div>\n<p>where <cite>b</cite> are the filter coefficients and <cite>N</cite> is the filter order (number of\ncoefficients - 1).</p>\n<ol class=\"arabic simple\">\n<li>Samples the input <cite>inputs[0]</cite> at intervals of <cite>T</cite>, starting after delay <cite>tau</cite>.</li>\n<li>Stores the current and past <cite>len(coefficients) - 1</cite> input samples in an internal buffer.</li>\n<li>Computes the filter output using the dot product of the coefficients\nand the buffered input samples.</li>\n<li>Outputs the result on <cite>outputs[0]</cite>.</li>\n<li>Holds the output constant between updates.</li>\n</ol>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>coeffs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array_like</span></dt>\n<dd>List or numpy array of FIR filter coefficients [b0, b1, ..., bN].\nThe number of coefficients determines the filter's order and memory.</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Sampling period (time between input samples and output updates). Default is 1.</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Initial delay before the first sample is processed. Default is 0.</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"input-ports\">\n<h3>Input Ports</h3>\n<dl class=\"docutils\">\n<dt>inputs[0] <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Input signal sample at the current time step.</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"output-ports\">\n<h3>Output Ports</h3>\n<dl class=\"docutils\">\n<dt>outputs[0] <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Filtered output signal sample.</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>buffer <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">deque</span></dt>\n<dd>Internal buffer storing the most recent input samples.</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>Internal scheduled event triggering the filter calculation.</dd>\n</dl>\n</div>\n",
    "params": {
      "coeffs": {
        "type": "array",
        "default": "[1.0]",
        "description": "List or numpy array of FIR filter coefficients [b0, b1, ..., bN]. The number of coefficients determines the filter's order and memory."
      },
      "T": {
        "type": "integer",
        "default": "1",
        "description": "Sampling period (time between input samples and output updates). Default is 1."
      },
      "tau": {
        "type": "integer",
        "default": "0",
        "description": "Initial delay before the first sample is processed. Default is 0."
      }
    },
    "inputs": [
      "in"
    ],
    "outputs": [
      "out"
    ]
  },
  "ADC": {
    "blockClass": "ADC",
    "description": "Models an ideal Analog-to-Digital Converter (ADC).",
    "docstringHtml": "<p>Models an ideal Analog-to-Digital Converter (ADC).</p>\n<p>This block samples an analog input signal periodically, quantizes it\naccording to the specified number of bits and input span, and outputs\nthe resulting digital code on multiple output ports. The sampling\nis triggered by a scheduled event.</p>\n<p>Functionality:</p>\n<ol class=\"arabic simple\">\n<li>Samples the analog input <cite>inputs[0]</cite> at intervals of <cite>T</cite>, starting after delay <cite>tau</cite>.</li>\n<li>Clips the input voltage to the defined <cite>span</cite> [min_voltage, max_voltage].</li>\n<li>Scales the clipped voltage to the range [0, 1].</li>\n<li>Quantizes the scaled value to an integer code between 0 and 2^n_bits - 1 using flooring.</li>\n<li>Converts the integer code to an n_bits binary representation.</li>\n<li>Outputs the binary code on ports 0 (LSB) to n_bits-1 (MSB).</li>\n</ol>\n<p>Ideal characteristics:</p>\n<ul class=\"simple\">\n<li>Instantaneous sampling at scheduled times.</li>\n<li>Perfect, noise-free quantization.</li>\n<li>No aperture jitter or other dynamic errors.</li>\n</ul>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>n_bits <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>Number of bits for the digital output code. Default is 4.</dd>\n<dt>span <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float] or tuple[float], optional</span></dt>\n<dd>The valid analog input value range [min_voltage, max_voltage].\nInputs outside this range will be clipped. Default is [-1, 1].</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Sampling period (time between samples). Default is 1 time unit.</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Initial delay before the first sample is taken. Default is 0.</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>Internal scheduled event responsible for periodic sampling and conversion.</dd>\n</dl>\n</div>\n",
    "params": {
      "n_bits": {
        "type": "integer",
        "default": "4",
        "description": "Number of bits for the digital output code. Default is 4."
      },
      "span": {
        "type": "array",
        "default": "[-1, 1]",
        "description": "The valid analog input value range [min_voltage, max_voltage]. Inputs outside this range will be clipped. Default is [-1, 1]."
      },
      "T": {
        "type": "integer",
        "default": "1",
        "description": "Sampling period (time between samples). Default is 1 time unit."
      },
      "tau": {
        "type": "integer",
        "default": "0",
        "description": "Initial delay before the first sample is taken. Default is 0."
      }
    },
    "inputs": [
      "in"
    ],
    "outputs": [
      "b4",
      "b3",
      "b2",
      "b1"
    ]
  },
  "DAC": {
    "blockClass": "DAC",
    "description": "Models an ideal Digital-to-Analog Converter (DAC).",
    "docstringHtml": "<p>Models an ideal Digital-to-Analog Converter (DAC).</p>\n<p>This block reads a digital input code periodically from its input ports,\nreconstructs the corresponding analog value based on the number of bits\nand output span, and holds the output constant between updates. The update\nis triggered by a scheduled event.</p>\n<p>Functionality:</p>\n<ol class=\"arabic simple\">\n<li>Reads the digital code from input ports 0 (LSB) to n_bits-1 (MSB) at intervals of <cite>T</cite>, starting after delay <cite>tau</cite>.</li>\n<li>Interprets the inputs as an unsigned binary integer code.</li>\n<li>Converts the integer code to a fractional value between 0 and (2^n_bits - 1) / 2^n_bits.</li>\n<li>Scales this fractional value to the specified analog output <cite>span</cite>.</li>\n<li>Outputs the resulting analog value on <cite>outputs[0]</cite>.</li>\n<li>Holds the output value constant until the next scheduled update.</li>\n</ol>\n<p>Ideal characteristics:</p>\n<ul class=\"simple\">\n<li>Instantaneous update at scheduled times.</li>\n<li>Perfect, noise-free reconstruction.</li>\n<li>No glitches or settling time.</li>\n</ul>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>n_bits <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, optional</span></dt>\n<dd>Number of digital input bits expected. Default is 4.</dd>\n<dt>span <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float] or tuple[float], optional</span></dt>\n<dd>The analog output value range [min_voltage, max_voltage] corresponding\nto the digital codes 0 and 2^n_bits - 1, respectively (approximately).\nDefault is [-1, 1].</dd>\n<dt>T <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Update period (time between output updates). Default is 1 time unit.</dd>\n<dt>tau <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float, optional</span></dt>\n<dd>Initial delay before the first output update. Default is 0.</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>Internal scheduled event responsible for periodic updates.</dd>\n</dl>\n</div>\n",
    "params": {
      "n_bits": {
        "type": "integer",
        "default": "4",
        "description": "Number of digital input bits expected. Default is 4."
      },
      "span": {
        "type": "array",
        "default": "[-1, 1]",
        "description": "The analog output value range [min_voltage, max_voltage] corresponding to the digital codes 0 and 2^n_bits - 1, respectively (approximately). Default is [-1, 1]."
      },
      "T": {
        "type": "integer",
        "default": "1",
        "description": "Update period (time between output updates). Default is 1 time unit."
      },
      "tau": {
        "type": "integer",
        "default": "0",
        "description": "Initial delay before the first output update. Default is 0."
      }
    },
    "inputs": [
      "b4",
      "b3",
      "b2",
      "b1"
    ],
    "outputs": [
      "out"
    ]
  },
  "Counter": {
    "blockClass": "Counter",
    "description": "Counter block that counts the number of detected bidirectional",
    "docstringHtml": "<p>Counter block that counts the number of detected bidirectional\nzero-crossing events and sets the output accordingly.</p>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter start (initial condition)</dd>\n<dt>threshold <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold for zero crossing</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>E <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ZeroCrossing</span></dt>\n<dd>internal event manager</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ZeroCrossing]</span></dt>\n<dd>internal zero crossing event</dd>\n</dl>\n</div>\n",
    "params": {
      "start": {
        "type": "integer",
        "default": "0",
        "description": "counter start (initial condition)"
      },
      "threshold": {
        "type": "number",
        "default": "0.0",
        "description": "threshold for zero crossing"
      }
    },
    "inputs": [
      "in"
    ],
    "outputs": [
      "out"
    ]
  },
  "CounterUp": {
    "blockClass": "CounterUp",
    "description": "Counter block that counts the number of detected unidirectional",
    "docstringHtml": "<p>Counter block that counts the number of detected unidirectional\nzero-crossing events and sets the output accordingly.</p>\n<div class=\"section\" id=\"note\">\n<h3>Note</h3>\n<p>This is a modification of 'Counter' which only counts\nunidirectional zero-crossings (low -&gt; high)</p>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter start (initial condition)</dd>\n<dt>threshold <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold for zero crossing</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>E <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ZeroCrossingUp</span></dt>\n<dd>internal event manager</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ZeroCrossing]</span></dt>\n<dd>internal zero crossing event</dd>\n</dl>\n</div>\n",
    "params": {
      "start": {
        "type": "integer",
        "default": "0",
        "description": "counter start (initial condition)"
      },
      "threshold": {
        "type": "number",
        "default": "0.0",
        "description": "threshold for zero crossing"
      }
    },
    "inputs": [
      "in"
    ],
    "outputs": [
      "out"
    ]
  },
  "CounterDown": {
    "blockClass": "CounterDown",
    "description": "Counter block that counts the number of detected unidirectional",
    "docstringHtml": "<p>Counter block that counts the number of detected unidirectional\nzero-crossing events and sets the output accordingly.</p>\n<div class=\"section\" id=\"note\">\n<h3>Note</h3>\n<p>This is a modification of 'Counter' which only counts\nunidirectional zero-crossings (high -&gt; low)</p>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>start <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>counter start (initial condition)</dd>\n<dt>threshold <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold for zero crossing</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>E <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">ZeroCrossingDown</span></dt>\n<dd>internal event manager</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ZeroCrossing]</span></dt>\n<dd>internal zero crossing event</dd>\n</dl>\n</div>\n",
    "params": {
      "start": {
        "type": "integer",
        "default": "0",
        "description": "counter start (initial condition)"
      },
      "threshold": {
        "type": "number",
        "default": "0.0",
        "description": "threshold for zero crossing"
      }
    },
    "inputs": [
      "in"
    ],
    "outputs": [
      "out"
    ]
  },
  "Relay": {
    "blockClass": "Relay",
    "description": "Relay block with hysteresis (Schmitt trigger).",
    "docstringHtml": "<p>Relay block with hysteresis (Schmitt trigger).</p>\n<p>Switches output between two values based on input crossing upper and lower\nthresholds. The hysteresis prevents rapid switching when input is noisy.</p>\n<p>When input rises above <cite>threshold_up</cite>, output switches to <cite>value_up</cite>.\nWhen input falls below <cite>threshold_down</cite>, output switches to <cite>value_down</cite>.</p>\n<div class=\"section\" id=\"examples\">\n<h3>Examples</h3>\n<p>Basic thermostat that turns heater on below 19C, off above 21C:</p>\n<pre class=\"code python literal-block\">\nfrom pathsim.blocks import Relay\n\nthermostat = Relay(\n    threshold_up=21.0,\n    threshold_down=19.0,\n    value_up=0.0,\n    value_down=1.0\n    )\n</pre>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>threshold_up <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold for transitioning to upper relay state <cite>value_up</cite> (default: 1.0)</dd>\n<dt>threshold_down <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>threshold for transitioning to lower relay state <cite>value_down</cite> (default: 0.0)</dd>\n<dt>value_up <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>value for upper relay state (default: 1.0)</dd>\n<dt>value_down <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>value for lower relay state (default: 0.0)</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[ZeroCrossingUp, ZeroCrossingDown]</span></dt>\n<dd>internal zero crossing events for relay state transitions</dd>\n</dl>\n</div>\n",
    "params": {
      "threshold_up": {
        "type": "number",
        "default": "1.0",
        "description": "threshold for transitioning to upper relay state `value_up` (default: 1.0)"
      },
      "threshold_down": {
        "type": "number",
        "default": "0.0",
        "description": "threshold for transitioning to lower relay state `value_down` (default: 0.0)"
      },
      "value_up": {
        "type": "number",
        "default": "1.0",
        "description": "value for upper relay state (default: 1.0)"
      },
      "value_down": {
        "type": "number",
        "default": "0.0",
        "description": "value for lower relay state (default: 0.0)"
      }
    },
    "inputs": [
      "in"
    ],
    "outputs": [
      "out"
    ]
  },
  "Scope": {
    "blockClass": "Scope",
    "description": "Block for recording time domain data with variable sampling rate.",
    "docstringHtml": "<p>Block for recording time domain data with variable sampling rate.</p>\n<p>A time threshold can be set by <cite>t_wait</cite> to start recording data after the simulation\ntime is larger then the specified waiting time, i.e. <cite>t - t_wait &gt; 0</cite>.\nThis is useful for recording data only after all the transients have settled.</p>\n<p>The block uses an interal <cite>Schedule</cite> event, when <cite>sampling_rate</cite> is provided,\notherwise it just samples at every simulation timestep.</p>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>sampling_rate <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int, None</span></dt>\n<dd>number of samples per time unit, default is every timestep</dd>\n<dt>t_wait <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>wait time before starting recording, optional</dd>\n<dt>labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[str]</span></dt>\n<dd>labels for the scope traces, and for the csv, optional</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>recording_time <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>recorded time points</dd>\n<dt>recording_data <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[float]</span></dt>\n<dd>regorded data points</dd>\n<dt>_incremental_idx <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>index for incremental reading of accumulated data since last\ncall of incremental read</dd>\n<dt>_sample_next_timestep <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">bool</span></dt>\n<dd>flag to indicate this is a timestep to sample, only used for\nevent based sampling when <cite>sampling_rate</cite> is provided as an arg</dd>\n<dt>events <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Schedule]</span></dt>\n<dd>internal scheduled event for periodic input sampling when\n<cite>sampling_rate</cite> is provided</dd>\n</dl>\n</div>\n",
    "params": {
      "sampling_rate": {
        "type": "any",
        "default": null,
        "description": "number of samples per time unit, default is every timestep"
      },
      "t_wait": {
        "type": "number",
        "default": "0.0",
        "description": "wait time before starting recording, optional"
      },
      "labels": {
        "type": "any",
        "default": null,
        "description": "labels for the scope traces, and for the csv, optional"
      }
    },
    "inputs": [],
    "outputs": []
  },
  "Spectrum": {
    "blockClass": "Spectrum",
    "description": "Block for fourier spectrum analysis (basically a spectrum analyzer), computes",
    "docstringHtml": "<p>Block for fourier spectrum analysis (basically a spectrum analyzer), computes\ncontinuous time running fourier transform (RFT) of the incoming signal.</p>\n<p>A time threshold can be set by 't_wait' to start recording data only after the\nsimulation time is larger then the specified waiting time, i.e. 't - t_wait &gt; dt'.\nThis is useful for recording the steady state after all the transients have settled.</p>\n<p>An exponential forgetting factor 'alpha' can be specified for realtime spectral\nanalysis. It biases the spectral components exponentially to the most recent signal\nvalues by applying a single sided exponential window like this:</p>\n<div class=\"math\">\n\\begin{equation*}\n\\int_0^t u(\\tau) \\exp(\\alpha (t-\\tau))  \\exp(-j \\omega \\tau)\\ d \\tau\n\\end{equation*}\n</div>\n<p>It is also known as the 'exponentially forgetting transform' (EFT) and a form of\nshort time fourier transform (STFT). It is implemented as a 1st order statespace model</p>\n<div class=\"math\">\n\\begin{equation*}\n\\dot{x} = - \\alpha  x +  \\exp(-j \\omega t) u\n\\end{equation*}\n</div>\n<p>where 'u' is the input signal and 'x' is the state variable that represents the\ncomplex fourier coefficient to the frequency 'omega'. The ODE is integrated using the\nnumerical integration engine of the block.</p>\n<div class=\"section\" id=\"example\">\n<h3>Example</h3>\n<p>This is how to initialize it:</p>\n<pre class=\"code python literal-block\">\nimport numpy as np\n\n#linear frequencies (0Hz, DC -&gt; 1kHz)\nsp1 = Spectrum(\n    freq=np.linspace(0, 1e3, 100),\n    labels=['x1', 'x2'] #labels for two inputs\n    )\n\n#log frequencies (1Hz -&gt; 1kHz)\nsp2 = Spectrum(\n    freq=np.logspace(0, 3, 100)\n    )\n\n#log frequencies including DC (0Hz, DC + 1Hz -&gt; 1kHz)\nsp3 = Spectrum(\n    freq=np.hstack([0.0, np.logspace(0, 3, 100)])\n    )\n\n#arbitrary frequencies\nsp4 = Spectrum(\n    freq=np.array([0, 0.5, 20, 1e3])\n    )\n</pre>\n</div>\n<div class=\"section\" id=\"note\">\n<h3>Note</h3>\n<p>This block is relatively slow! But it is valuable for long running simulations\nwith few evaluation frequencies, where just FFT'ing the time series data\nwouldnt be efficient OR if only the evaluation at weirdly spaced frequencies\nis required. Otherwise its more efficient to just do an FFT on the time\nseries recording after the simulation has finished.</p>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>freq <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array[float]</span></dt>\n<dd>list of evaluation frequencies for RFT, can be arbitrarily spaced</dd>\n<dt>t_wait <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>wait time before starting RFT</dd>\n<dt>alpha <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>exponential forgetting factor for realtime spectrum</dd>\n<dt>labels <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[str]</span></dt>\n<dd>labels for the inputs</dd>\n</dl>\n</div>\n",
    "params": {
      "freq": {
        "type": "array",
        "default": "[]",
        "description": "list of evaluation frequencies for RFT, can be arbitrarily spaced"
      },
      "t_wait": {
        "type": "number",
        "default": "0.0",
        "description": "wait time before starting RFT"
      },
      "alpha": {
        "type": "number",
        "default": "0.0",
        "description": "exponential forgetting factor for realtime spectrum"
      },
      "labels": {
        "type": "array",
        "default": "[]",
        "description": "labels for the inputs"
      }
    },
    "inputs": [],
    "outputs": []
  },
  "Subsystem": {
    "blockClass": "Subsystem",
    "description": "Subsystem class that holds its own blocks and connecions and",
    "docstringHtml": "<p>Subsystem class that holds its own blocks and connecions and\ncan natively interface with the main simulation loop.</p>\n<p>IO interface is realized by a special 'Interface' block, that has extra\nmethods for setting and getting inputs and outputs and serves\nas the interface of the internal blocks to the outside.</p>\n<p>The subsystem doesnt use its 'inputs' and 'outputs' dicts directly.\nIt exclusively handles data transfer via the 'Interface' block.</p>\n<p>This class can be used just like any other block during the simulation,\nsince it implements the required methods 'update' for the fixed-point\niteration (resolving algebraic loops with instant time blocks),\nthe 'step' method that performs timestepping (especially for dynamic\nblocks with internal states) and the 'solve' method for solving the\nimplicit update equation for implicit solvers.</p>\n<div class=\"section\" id=\"example\">\n<h3>Example</h3>\n<p>This is how we can wrap up multiple blocks within a subsystem.\nIn this case vanderpol system built from discrete components\ninstead of using an ODE block (in practice you should use\na monolithic ODE whenever possible due to performance).</p>\n<pre class=\"code python literal-block\">\nfrom pathsim import Subsystem, Interface, Connection\nfrom pathsim.blocks import Integrator, Function\n\n#van der Pol parameter\nmu = 1000\n\n#blocks in the subsystem\nIf = Interface() # this is the interface to the outside\nI1 = Integrator(2)\nI2 = Integrator(0)\nFn = Function(lambda x1, x2: mu*(1 - x1**2)*x2 - x1)\n\nsub_blocks = [If, I1, I2, Fn]\n\n#connections in the subsystem\nsub_connections = [\n    Connection(I2, I1, Fn[1], If[1]),\n    Connection(I1, Fn, If),\n    Connection(Fn, I2)\n    ]\n\n#the subsystem acts just like a normal block\nvdp = Subsystem(sub_blocks, sub_connections)\n</pre>\n</div>\n<div class=\"section\" id=\"parameters\">\n<h3>Parameters</h3>\n<dl class=\"docutils\">\n<dt>blocks <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Block] | None</span></dt>\n<dd>internal blocks of the subsystem</dd>\n<dt>connections <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">list[Connection] | None</span></dt>\n<dd>internal connections of the subsystem</dd>\n</dl>\n<p>events : list[Event] | None\ntolerance_fpi : float</p>\n<blockquote>\nabsolute tolerance for convergence of algebraic loops\ndefault see SIM_TOLERANCE_FPI in _constants.py</blockquote>\n<dl class=\"docutils\">\n<dt>iterations_max <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>maximum allowed number of iterations for algebraic loop\nsolver, default see SIM_ITERATIONS_MAX in _constants.py</dd>\n</dl>\n</div>\n<div class=\"section\" id=\"attributes\">\n<h3>Attributes</h3>\n<dl class=\"docutils\">\n<dt>interface <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Interface</span></dt>\n<dd>internal interface block for data transfer to the outside</dd>\n<dt>graph <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">Graph</span></dt>\n<dd>internal graph representation for fast system funcion\nevluations using DAG with algebraic depths</dd>\n<dt>boosters <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">None | list[ConnectionBooster]</span></dt>\n<dd>list of boosters (fixed point accelerators) that wrap\nalgebraic loop closing connections assembled from the\nsystem graph</dd>\n</dl>\n</div>\n",
    "params": {
      "blocks": {
        "type": "any",
        "default": null,
        "description": "internal blocks of the subsystem"
      },
      "connections": {
        "type": "any",
        "default": null,
        "description": "internal connections of the subsystem"
      },
      "events": {
        "type": "any",
        "default": null,
        "description": ""
      },
      "tolerance_fpi": {
        "type": "number",
        "default": "1e-10",
        "description": "absolute tolerance for convergence of algebraic loops default see SIM_TOLERANCE_FPI in _constants.py"
      },
      "iterations_max": {
        "type": "integer",
        "default": "200",
        "description": "maximum allowed number of iterations for algebraic loop solver, default see SIM_ITERATIONS_MAX in _constants.py"
      }
    },
    "inputs": [],
    "outputs": []
  },
  "Interface": {
    "blockClass": "Interface",
    "description": "Bare-bone block that serves as a data interface for the 'Subsystem' class.",
    "docstringHtml": "<p>Bare-bone block that serves as a data interface for the 'Subsystem' class.</p>\n<p>It works like this:</p>\n<ul class=\"simple\">\n<li>Internal blocks of the subsystem are connected to the inputs and outputs\nof this Interface block via the internal connections.</li>\n<li>It behaves like a normal block (inherits the main 'Block' class methods).</li>\n<li>It implements some special methods to get and set the inputs and outputs\nof the blocks, that are used to translate between the internal blocks of the\nsubsystem and the inputs and outputs of the subsystem.</li>\n<li>Handles data transfer to and from the internal subsystem blocks\nto and from the inputs and outputs of the subsystem.</li>\n</ul>\n",
    "params": {},
    "inputs": [],
    "outputs": []
  }
};

export const blockConfig: Record<Exclude<NodeCategory, 'Subsystem'>, string[]> = {
  Sources: ["Constant", "Source", "SinusoidalSource", "StepSource", "PulseSource", "TriangleWaveSource", "SquareWaveSource", "GaussianPulseSource", "ChirpPhaseNoiseSource", "ClockSource", "WhiteNoise", "PinkNoise", "RandomNumberGenerator"],
  Dynamic: ["Integrator", "Differentiator", "Delay", "ODE", "DynamicalSystem", "StateSpace", "PID", "AntiWindupPID", "TransferFunctionNumDen", "TransferFunctionZPG", "ButterworthLowpassFilter", "ButterworthHighpassFilter", "ButterworthBandpassFilter", "ButterworthBandstopFilter"],
  Algebraic: ["Adder", "Multiplier", "Amplifier", "Function", "Sin", "Cos", "Tan", "Tanh", "Abs", "Sqrt", "Exp", "Log", "Log10", "Mod", "Clip", "Pow", "Switch", "LUT", "LUT1D"],
  Mixed: ["SampleHold", "FIR", "ADC", "DAC", "Counter", "CounterUp", "CounterDown", "Relay"],
  Recording: ["Scope", "Spectrum"],
};

export const uiOverrides: Record<string, UIOverride> = 
{
  "Constant": {
    "maxInputs": 0,
    "maxOutputs": 1
  },
  "Source": {
    "maxInputs": 0,
    "maxOutputs": 1
  },
  "SinusoidalSource": {
    "maxInputs": 0,
    "maxOutputs": 1
  },
  "StepSource": {
    "maxInputs": 0,
    "maxOutputs": 1
  },
  "PulseSource": {
    "maxInputs": 0,
    "maxOutputs": 1
  },
  "TriangleWaveSource": {
    "maxInputs": 0,
    "maxOutputs": 1
  },
  "SquareWaveSource": {
    "maxInputs": 0,
    "maxOutputs": 1
  },
  "GaussianPulseSource": {
    "maxInputs": 0,
    "maxOutputs": 1
  },
  "ClockSource": {
    "maxInputs": 0,
    "maxOutputs": 1
  },
  "WhiteNoise": {
    "maxInputs": 0,
    "maxOutputs": 1
  },
  "PinkNoise": {
    "maxInputs": 0,
    "maxOutputs": 1
  },
  "ChirpPhaseNoiseSource": {
    "maxInputs": 0,
    "maxOutputs": 1
  },
  "RandomNumberGenerator": {
    "maxInputs": 0,
    "maxOutputs": 1
  },
  "Integrator": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "Differentiator": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "Delay": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "ODE": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "DynamicalSystem": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "StateSpace": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "PID": {
    "maxInputs": 1,
    "maxOutputs": 1
  },
  "AntiWindupPID": {
    "maxInputs": 1,
    "maxOutputs": 1
  },
  "TransferFunctionNumDen": {
    "maxInputs": 1,
    "maxOutputs": 1
  },
  "TransferFunctionZPG": {
    "maxInputs": 1,
    "maxOutputs": 1
  },
  "ButterworthLowpassFilter": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "ButterworthHighpassFilter": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "ButterworthBandpassFilter": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "ButterworthBandstopFilter": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "Adder": {
    "maxInputs": null,
    "maxOutputs": 1
  },
  "Multiplier": {
    "maxInputs": null,
    "maxOutputs": 1
  },
  "Amplifier": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "Function": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "Sin": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "Cos": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "Tan": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "Tanh": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "Abs": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "Sqrt": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "Exp": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "Log": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "Log10": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "Mod": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "Clip": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "Pow": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "Switch": {
    "maxInputs": null,
    "maxOutputs": 1
  },
  "LUT": {
    "maxInputs": null,
    "maxOutputs": null
  },
  "LUT1D": {
    "maxInputs": 1,
    "maxOutputs": 1
  },
  "SampleHold": {},
  "FIR": {},
  "ADC": {},
  "DAC": {},
  "Counter": {
    "maxInputs": 1,
    "maxOutputs": 1
  },
  "CounterUp": {
    "maxInputs": 1,
    "maxOutputs": 1
  },
  "CounterDown": {
    "maxInputs": 1,
    "maxOutputs": 1
  },
  "Relay": {
    "maxInputs": 1,
    "maxOutputs": 1
  },
  "Scope": {
    "maxInputs": null,
    "maxOutputs": 0
  },
  "Spectrum": {
    "maxInputs": null,
    "maxOutputs": 0
  },
  "Splitter": {
    "maxInputs": 1,
    "maxOutputs": null
  },
  "Process": {
    "maxOutputs": 2
  },
  "GLC": {
    "maxInputs": 4,
    "maxOutputs": 8
  },
  "Bubbler4": {
    "maxInputs": 2,
    "maxOutputs": 5
  }
};
