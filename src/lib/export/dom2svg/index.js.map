{"version":3,"sources":["../src/utils/dom.ts","../src/utils/id-generator.ts","../src/core/styles.ts","../src/utils/geometry.ts","../src/assets/gradients.ts","../src/assets/images.ts","../src/transforms/parse.ts","../src/transforms/matrix.ts","../src/transforms/svg.ts","../src/assets/filters.ts","../src/assets/box-shadow.ts","../src/assets/clip-path.ts","../src/renderers/html-element.ts","../src/renderers/svg-element.ts","../src/assets/fonts.ts","../src/assets/text-shadow.ts","../src/renderers/text-node.ts","../src/core/traversal.ts","../src/compat.ts","../src/index.ts"],"sourcesContent":["export const SVG_NS = \"http://www.w3.org/2000/svg\";\r\nexport const XLINK_NS = \"http://www.w3.org/1999/xlink\";\r\nexport const XMLNS_NS = \"http://www.w3.org/2000/xmlns/\";\r\n\r\n/** Check if a node is an Element */\r\nexport function isElement(node: Node): node is Element {\r\n  return node.nodeType === Node.ELEMENT_NODE;\r\n}\r\n\r\n/** Check if a node is a Text node */\r\nexport function isTextNode(node: Node): node is Text {\r\n  return node.nodeType === Node.TEXT_NODE;\r\n}\r\n\r\n/** Check if an element is an SVG element */\r\nexport function isSvgElement(element: Element): element is SVGElement {\r\n  return element.namespaceURI === SVG_NS;\r\n}\r\n\r\n/** Check if an element is an HTMLImageElement */\r\nexport function isImageElement(element: Element): element is HTMLImageElement {\r\n  return element instanceof HTMLImageElement;\r\n}\r\n\r\n/** Check if an element is an HTMLCanvasElement */\r\nexport function isCanvasElement(element: Element): element is HTMLCanvasElement {\r\n  return element instanceof HTMLCanvasElement;\r\n}\r\n\r\n/** Check if an element is a form control with a text value */\r\nexport function isFormElement(\r\n  element: Element,\r\n): element is HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement {\r\n  return (\r\n    element instanceof HTMLInputElement ||\r\n    element instanceof HTMLTextAreaElement ||\r\n    element instanceof HTMLSelectElement\r\n  );\r\n}\r\n\r\n/** Create an SVG element in the SVG namespace */\r\nexport function createSvgElement<K extends keyof SVGElementTagNameMap>(\r\n  doc: Document,\r\n  tagName: K,\r\n): SVGElementTagNameMap[K];\r\nexport function createSvgElement(doc: Document, tagName: string): SVGElement;\r\nexport function createSvgElement(doc: Document, tagName: string): SVGElement {\r\n  return doc.createElementNS(SVG_NS, tagName);\r\n}\r\n\r\n/** Set multiple attributes on an SVG element */\r\nexport function setAttributes(\r\n  element: SVGElement,\r\n  attrs: Record<string, string | number>,\r\n): void {\r\n  for (const [key, value] of Object.entries(attrs)) {\r\n    element.setAttribute(key, String(value));\r\n    // Also set xlink:href for SVG 1.1 compatibility (e.g. Figma, re-parsed SVG)\r\n    if (key === \"href\") {\r\n      element.setAttributeNS(XLINK_NS, \"xlink:href\", String(value));\r\n    }\r\n  }\r\n}\r\n\r\n/** Get computed style for pseudo-elements */\r\nexport function getPseudoStyles(\r\n  element: Element,\r\n  pseudo: \"::before\" | \"::after\",\r\n): CSSStyleDeclaration {\r\n  return window.getComputedStyle(element, pseudo);\r\n}\r\n","import type { IdGenerator } from \"../types.js\";\r\n\r\n/** Global counter shared across all generators to avoid ID collisions\r\n *  when multiple SVGs are embedded in the same HTML document. */\r\nlet globalCounter = 0;\r\n\r\n/** Creates an ID generator that produces unique IDs with an optional prefix */\r\nexport function createIdGenerator(): IdGenerator {\r\n  return {\r\n    next(prefix = \"d2s\"): string {\r\n      return `${prefix}-${globalCounter++}`;\r\n    },\r\n  };\r\n}\r\n\r\n/** Reset the global counter (for testing only) */\r\nexport function resetIdCounter(): void {\r\n  globalCounter = 0;\r\n}\r\n","import type { BorderSide, Borders, BorderRadii } from \"../types.js\";\r\n\r\n/** Check if an element's entire subtree should be skipped (display:none) */\r\nexport function isInvisible(styles: CSSStyleDeclaration): boolean {\r\n  return styles.display === \"none\";\r\n}\r\n\r\n/** Check if element's own visuals are hidden (children may still be visible) */\r\nexport function isVisibilityHidden(styles: CSSStyleDeclaration): boolean {\r\n  return styles.visibility === \"hidden\";\r\n}\r\n\r\n/** Parse a single border side from computed styles */\r\nfunction parseBorderSide(\r\n  width: string,\r\n  style: string,\r\n  color: string,\r\n): BorderSide {\r\n  return {\r\n    width: parseFloat(width) || 0,\r\n    style,\r\n    color,\r\n  };\r\n}\r\n\r\n/** Parse all four borders from computed styles */\r\nexport function parseBorders(styles: CSSStyleDeclaration): Borders {\r\n  return {\r\n    top: parseBorderSide(\r\n      styles.borderTopWidth,\r\n      styles.borderTopStyle,\r\n      styles.borderTopColor,\r\n    ),\r\n    right: parseBorderSide(\r\n      styles.borderRightWidth,\r\n      styles.borderRightStyle,\r\n      styles.borderRightColor,\r\n    ),\r\n    bottom: parseBorderSide(\r\n      styles.borderBottomWidth,\r\n      styles.borderBottomStyle,\r\n      styles.borderBottomColor,\r\n    ),\r\n    left: parseBorderSide(\r\n      styles.borderLeftWidth,\r\n      styles.borderLeftStyle,\r\n      styles.borderLeftColor,\r\n    ),\r\n  };\r\n}\r\n\r\n/** Parse border-radius into [horizontal, vertical] pairs in px */\r\nexport function parseBorderRadii(styles: CSSStyleDeclaration): BorderRadii {\r\n  return {\r\n    topLeft: parseRadiusPair(styles.borderTopLeftRadius),\r\n    topRight: parseRadiusPair(styles.borderTopRightRadius),\r\n    bottomRight: parseRadiusPair(styles.borderBottomRightRadius),\r\n    bottomLeft: parseRadiusPair(styles.borderBottomLeftRadius),\r\n  };\r\n}\r\n\r\nfunction parseRadiusPair(value: string): [number, number] {\r\n  const parts = value.split(/\\s+/).map((v) => parseFloat(v) || 0);\r\n  return [parts[0] ?? 0, parts[1] ?? parts[0] ?? 0];\r\n}\r\n\r\n/** Check if any border has a visible width */\r\nexport function hasBorder(borders: Borders): boolean {\r\n  return (\r\n    (borders.top.width > 0 && borders.top.style !== \"none\") ||\r\n    (borders.right.width > 0 && borders.right.style !== \"none\") ||\r\n    (borders.bottom.width > 0 && borders.bottom.style !== \"none\") ||\r\n    (borders.left.width > 0 && borders.left.style !== \"none\")\r\n  );\r\n}\r\n\r\n/** Check if any border-radius is non-zero */\r\nexport function hasRadius(radii: BorderRadii): boolean {\r\n  return (\r\n    radii.topLeft[0] > 0 ||\r\n    radii.topLeft[1] > 0 ||\r\n    radii.topRight[0] > 0 ||\r\n    radii.topRight[1] > 0 ||\r\n    radii.bottomRight[0] > 0 ||\r\n    radii.bottomRight[1] > 0 ||\r\n    radii.bottomLeft[0] > 0 ||\r\n    radii.bottomLeft[1] > 0\r\n  );\r\n}\r\n\r\n/** Check if all four radii corners are identical (uniform) */\r\nexport function isUniformRadius(radii: BorderRadii): boolean {\r\n  const [rx, ry] = radii.topLeft;\r\n  return (\r\n    radii.topRight[0] === rx &&\r\n    radii.topRight[1] === ry &&\r\n    radii.bottomRight[0] === rx &&\r\n    radii.bottomRight[1] === ry &&\r\n    radii.bottomLeft[0] === rx &&\r\n    radii.bottomLeft[1] === ry\r\n  );\r\n}\r\n\r\n/** Check if element has overflow clipping (hidden, clip, scroll, auto all clip) */\r\nexport function hasOverflowClip(styles: CSSStyleDeclaration): boolean {\r\n  const clipped = new Set([\"hidden\", \"clip\", \"scroll\", \"auto\"]);\r\n  return (\r\n    clipped.has(styles.overflow) ||\r\n    clipped.has(styles.overflowX) ||\r\n    clipped.has(styles.overflowY)\r\n  );\r\n}\r\n\r\n/** Parse background-color, return null if transparent */\r\nexport function parseBackgroundColor(\r\n  styles: CSSStyleDeclaration,\r\n): string | null {\r\n  const bg = styles.backgroundColor;\r\n  if (!bg || bg === \"transparent\" || bg === \"rgba(0, 0, 0, 0)\") return null;\r\n  return bg;\r\n}\r\n\r\n/** Check if there's a background-image (gradient or url) */\r\nexport function hasBackgroundImage(styles: CSSStyleDeclaration): boolean {\r\n  return !!styles.backgroundImage && styles.backgroundImage !== \"none\";\r\n}\r\n\r\n/** Parse opacity value */\r\nexport function parseOpacity(styles: CSSStyleDeclaration): number {\r\n  const value = parseFloat(styles.opacity);\r\n  return isNaN(value) ? 1 : value;\r\n}\r\n\r\n/** Check if element creates a new stacking context */\r\nexport function createsStackingContext(styles: CSSStyleDeclaration): boolean {\r\n  // Positioned with z-index != auto\r\n  if (\r\n    styles.position !== \"static\" &&\r\n    styles.position !== \"\" &&\r\n    styles.zIndex !== \"auto\"\r\n  ) {\r\n    return true;\r\n  }\r\n  // Opacity less than 1\r\n  if (parseFloat(styles.opacity) < 1) return true;\r\n  // CSS transforms\r\n  if (styles.transform && styles.transform !== \"none\") return true;\r\n  // Filter\r\n  if (styles.filter && styles.filter !== \"none\") return true;\r\n  // Isolation\r\n  if (styles.isolation === \"isolate\") return true;\r\n  // Mix blend mode\r\n  if (styles.mixBlendMode && styles.mixBlendMode !== \"normal\") return true;\r\n\r\n  return false;\r\n}\r\n\r\n/** Get the z-index as a number (0 for auto) */\r\nexport function getZIndex(styles: CSSStyleDeclaration): number {\r\n  if (styles.zIndex === \"auto\" || !styles.zIndex) return 0;\r\n  return parseInt(styles.zIndex, 10) || 0;\r\n}\r\n\r\n/** Check if element is positioned */\r\nexport function isPositioned(styles: CSSStyleDeclaration): boolean {\r\n  return styles.position !== \"static\" && styles.position !== \"\";\r\n}\r\n\r\n/** Check if element is a float */\r\nexport function isFloat(styles: CSSStyleDeclaration): boolean {\r\n  return styles.cssFloat !== \"none\" && styles.cssFloat !== \"\";\r\n}\r\n\r\n/**\r\n * Clamp border-radii to fit the box, following the CSS spec algorithm:\r\n * compute the ratio for each side, use the minimum to scale all radii.\r\n */\r\nexport function clampRadii(radii: BorderRadii, width: number, height: number): BorderRadii {\r\n  // Horizontal sums (top and bottom edges)\r\n  const topH = radii.topLeft[0] + radii.topRight[0];\r\n  const bottomH = radii.bottomLeft[0] + radii.bottomRight[0];\r\n  // Vertical sums (left and right edges)\r\n  const leftV = radii.topLeft[1] + radii.bottomLeft[1];\r\n  const rightV = radii.topRight[1] + radii.bottomRight[1];\r\n\r\n  let f = 1;\r\n  if (topH > 0) f = Math.min(f, width / topH);\r\n  if (bottomH > 0) f = Math.min(f, width / bottomH);\r\n  if (leftV > 0) f = Math.min(f, height / leftV);\r\n  if (rightV > 0) f = Math.min(f, height / rightV);\r\n\r\n  if (f >= 1) return radii;\r\n\r\n  return {\r\n    topLeft: [radii.topLeft[0] * f, radii.topLeft[1] * f],\r\n    topRight: [radii.topRight[0] * f, radii.topRight[1] * f],\r\n    bottomRight: [radii.bottomRight[0] * f, radii.bottomRight[1] * f],\r\n    bottomLeft: [radii.bottomLeft[0] * f, radii.bottomLeft[1] * f],\r\n  };\r\n}\r\n\r\n/** Check if element is inline-level */\r\nexport function isInlineLevel(styles: CSSStyleDeclaration): boolean {\r\n  const d = styles.display;\r\n  return (\r\n    d === \"inline\" ||\r\n    d === \"inline-block\" ||\r\n    d === \"inline-flex\" ||\r\n    d === \"inline-grid\" ||\r\n    d === \"inline-table\"\r\n  );\r\n}\r\n","import type { BoxGeometry, BorderRadii } from \"../types.js\";\r\n\r\n/** Get an element's bounding box relative to a root element */\r\nexport function getRelativeBox(element: Element, root: Element): BoxGeometry {\r\n  const elRect = element.getBoundingClientRect();\r\n  const rootRect = root.getBoundingClientRect();\r\n  return {\r\n    x: elRect.left - rootRect.left,\r\n    y: elRect.top - rootRect.top,\r\n    width: elRect.width,\r\n    height: elRect.height,\r\n  };\r\n}\r\n\r\n/** Build an SVG path d-attribute for a rounded rectangle with non-uniform radii */\r\nexport function buildRoundedRectPath(\r\n  x: number, y: number, width: number, height: number,\r\n  radii: BorderRadii,\r\n): string {\r\n  const [tlx, tly] = radii.topLeft;\r\n  const [trx, try_] = radii.topRight;\r\n  const [brx, bry] = radii.bottomRight;\r\n  const [blx, bly] = radii.bottomLeft;\r\n\r\n  return [\r\n    `M ${x + tlx} ${y}`,\r\n    `L ${x + width - trx} ${y}`,\r\n    trx || try_ ? `A ${trx} ${try_} 0 0 1 ${x + width} ${y + try_}` : \"\",\r\n    `L ${x + width} ${y + height - bry}`,\r\n    brx || bry ? `A ${brx} ${bry} 0 0 1 ${x + width - brx} ${y + height}` : \"\",\r\n    `L ${x + blx} ${y + height}`,\r\n    blx || bly ? `A ${blx} ${bly} 0 0 1 ${x} ${y + height - bly}` : \"\",\r\n    `L ${x} ${y + tly}`,\r\n    tlx || tly ? `A ${tlx} ${tly} 0 0 1 ${x + tlx} ${y}` : \"\",\r\n    \"Z\",\r\n  ].filter(Boolean).join(\" \");\r\n}\r\n","import type { LinearGradient, GradientStop, RenderContext, BoxGeometry } from \"../types.js\";\r\nimport { createSvgElement, setAttributes } from \"../utils/dom.js\";\r\n\r\n/** Parse a CSS linear-gradient() into our LinearGradient structure */\r\nexport function parseLinearGradient(value: string): LinearGradient | null {\r\n  // Match linear-gradient(...) - handle both prefix and standard\r\n  const match = value.match(/linear-gradient\\((.+)\\)/);\r\n  if (!match) return null;\r\n\r\n  const body = match[1]!;\r\n  const parts = splitGradientArgs(body);\r\n  if (parts.length < 2) return null;\r\n\r\n  let angle = 180; // default: to bottom\r\n  let stopsStart = 0;\r\n\r\n  // Check if first part is a direction\r\n  const first = parts[0]!.trim();\r\n  if (first.startsWith(\"to \")) {\r\n    angle = directionToAngle(first);\r\n    stopsStart = 1;\r\n  } else if (first.match(/^-?[\\d.]+(?:deg|rad|turn|grad)/)) {\r\n    angle = parseAngle(first);\r\n    stopsStart = 1;\r\n  }\r\n\r\n  const stops: GradientStop[] = [];\r\n  const rawStops = parts.slice(stopsStart);\r\n\r\n  for (let i = 0; i < rawStops.length; i++) {\r\n    const { color, position } = parseColorStop(rawStops[i]!.trim(), i, rawStops.length);\r\n    stops.push({ color, position });\r\n  }\r\n\r\n  return { angle, stops };\r\n}\r\n\r\n/** Convert a linear-gradient to an SVG <linearGradient> element */\r\nexport function createSvgLinearGradient(\r\n  gradient: LinearGradient,\r\n  box: BoxGeometry,\r\n  ctx: RenderContext,\r\n): SVGLinearGradientElement {\r\n  const id = ctx.idGenerator.next(\"grad\");\r\n  const el = createSvgElement(\r\n    ctx.svgDocument,\r\n    \"linearGradient\",\r\n  ) as SVGLinearGradientElement;\r\n\r\n  // Use userSpaceOnUse with pixel coordinates for correct diagonal angles\r\n  // on non-square elements (objectBoundingBox distorts the angle).\r\n  const cx = box.x + box.width / 2;\r\n  const cy = box.y + box.height / 2;\r\n  const angleRad = (gradient.angle * Math.PI) / 180;\r\n  // CSS angle: 0deg = to top (↑), 90deg = to right (→)\r\n  const dx = Math.sin(angleRad);\r\n  const dy = -Math.cos(angleRad);\r\n  // Gradient line half-length per CSS spec: extends to the perpendicular\r\n  // from the farthest corner.\r\n  const halfLen = Math.abs(box.width / 2 * dx) + Math.abs(box.height / 2 * dy);\r\n  const x1 = cx - dx * halfLen;\r\n  const y1 = cy - dy * halfLen;\r\n  const x2 = cx + dx * halfLen;\r\n  const y2 = cy + dy * halfLen;\r\n\r\n  setAttributes(el, {\r\n    id,\r\n    gradientUnits: \"userSpaceOnUse\",\r\n    x1: x1.toFixed(2),\r\n    y1: y1.toFixed(2),\r\n    x2: x2.toFixed(2),\r\n    y2: y2.toFixed(2),\r\n  });\r\n\r\n  for (const stop of gradient.stops) {\r\n    const stopEl = createSvgElement(ctx.svgDocument, \"stop\");\r\n    setAttributes(stopEl, {\r\n      offset: `${(stop.position * 100).toFixed(1)}%`,\r\n      \"stop-color\": stop.color,\r\n    });\r\n    el.appendChild(stopEl);\r\n  }\r\n\r\n  ctx.defs.appendChild(el);\r\n  return el;\r\n}\r\n\r\n/**\r\n * Rasterize a conic-gradient (or radial-gradient) to a data URL\r\n * using the Canvas 2D API. Returns null if the gradient type is\r\n * not supported or the Canvas API is unavailable.\r\n */\r\nexport function rasterizeGradient(\r\n  value: string,\r\n  width: number,\r\n  height: number,\r\n): string | null {\r\n  if (value.includes(\"conic-gradient\")) {\r\n    return rasterizeConicGradient(value, width, height);\r\n  }\r\n  if (value.includes(\"radial-gradient\")) {\r\n    return rasterizeRadialGradient(value, width, height);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction rasterizeConicGradient(\r\n  value: string,\r\n  width: number,\r\n  height: number,\r\n): string | null {\r\n  const match = value.match(/conic-gradient\\((.+)\\)/);\r\n  if (!match) return null;\r\n\r\n  const scale = 2;\r\n  const canvas = document.createElement(\"canvas\");\r\n  canvas.width = Math.ceil(width * scale);\r\n  canvas.height = Math.ceil(height * scale);\r\n  const ctx = canvas.getContext(\"2d\");\r\n  if (!ctx || !(\"createConicGradient\" in ctx)) return null;\r\n\r\n  ctx.scale(scale, scale);\r\n\r\n  const body = match[1]!;\r\n  const parts = splitGradientArgs(body);\r\n\r\n  let startDeg = 0;\r\n  let stopsStart = 0;\r\n\r\n  // Parse \"from <angle>\" prefix\r\n  const first = parts[0]!.trim();\r\n  const fromMatch = first.match(/^from\\s+(-?[\\d.]+)(deg|rad|turn|grad)/);\r\n  if (fromMatch) {\r\n    startDeg = parseAngle(fromMatch[1]! + fromMatch[2]!);\r\n    stopsStart = 1;\r\n  }\r\n\r\n  const cx = width / 2;\r\n  const cy = height / 2;\r\n\r\n  // CSS 0deg = top (12 o'clock), Canvas 0rad = right (3 o'clock)\r\n  const startRad = ((startDeg - 90) * Math.PI) / 180;\r\n  const gradient = ctx.createConicGradient(startRad, cx, cy);\r\n\r\n  const rawStops = parts.slice(stopsStart);\r\n  for (let i = 0; i < rawStops.length; i++) {\r\n    const stop = rawStops[i]!.trim();\r\n    const { color, position } = parseColorStop(stop, i, rawStops.length);\r\n    try {\r\n      gradient.addColorStop(position, color);\r\n    } catch {\r\n      // Invalid color — skip\r\n    }\r\n  }\r\n\r\n  ctx.fillStyle = gradient;\r\n  ctx.fillRect(0, 0, width, height);\r\n  return canvas.toDataURL(\"image/png\");\r\n}\r\n\r\nfunction rasterizeRadialGradient(\r\n  value: string,\r\n  width: number,\r\n  height: number,\r\n): string | null {\r\n  const match = value.match(/radial-gradient\\((.+)\\)/);\r\n  if (!match) return null;\r\n\r\n  const scale = 2;\r\n  const canvas = document.createElement(\"canvas\");\r\n  canvas.width = Math.ceil(width * scale);\r\n  canvas.height = Math.ceil(height * scale);\r\n  const ctx = canvas.getContext(\"2d\");\r\n  if (!ctx) return null;\r\n\r\n  ctx.scale(scale, scale);\r\n\r\n  const body = match[1]!;\r\n  const parts = splitGradientArgs(body);\r\n\r\n  let isCircle = false;\r\n  let stopsStart = 0;\r\n  let customCx: number | null = null;\r\n  let customCy: number | null = null;\r\n\r\n  // Check if the first part is a shape/size descriptor\r\n  const first = parts[0]!.trim();\r\n  if (first === \"circle\" || first.startsWith(\"circle \")) {\r\n    isCircle = true;\r\n    stopsStart = 1;\r\n  } else if (first === \"ellipse\" || first.startsWith(\"ellipse \")) {\r\n    stopsStart = 1;\r\n  } else if (first.includes(\"at \") && !first.includes(\"#\") && !first.match(/^(rgb|hsl)/)) {\r\n    stopsStart = 1;\r\n  }\r\n\r\n  // Parse \"at cx cy\" position from shape descriptor\r\n  if (stopsStart === 1) {\r\n    const atMatch = first.match(/at\\s+(.+)/);\r\n    if (atMatch) {\r\n      const posParts = atMatch[1]!.trim().split(/\\s+/);\r\n      customCx = parseLengthOrPercent(posParts[0]!, width);\r\n      customCy = parseLengthOrPercent(posParts[1] ?? posParts[0]!, height);\r\n    }\r\n  }\r\n\r\n  const cx = customCx ?? width / 2;\r\n  const cy = customCy ?? height / 2;\r\n\r\n  // Use transform to create an elliptical gradient\r\n  const rx = width / 2;\r\n  const ry = height / 2;\r\n  // CSS default: farthest-corner. For a circle, that's the distance to the corner.\r\n  const radius = isCircle ? Math.sqrt(rx * rx + ry * ry) : Math.max(rx, ry);\r\n\r\n  ctx.save();\r\n  if (!isCircle && rx !== ry) {\r\n    ctx.translate(cx, cy);\r\n    ctx.scale(rx / radius, ry / radius);\r\n    ctx.translate(-cx, -cy);\r\n  }\r\n\r\n  const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);\r\n\r\n  const rawStops = parts.slice(stopsStart);\r\n  for (let i = 0; i < rawStops.length; i++) {\r\n    const stop = rawStops[i]!.trim();\r\n    const { color, position } = parseColorStop(stop, i, rawStops.length);\r\n    try {\r\n      gradient.addColorStop(position, color);\r\n    } catch {\r\n      // Invalid color — skip\r\n    }\r\n  }\r\n\r\n  ctx.fillStyle = gradient;\r\n  // When the elliptical transform compresses one axis, the fillRect must\r\n  // be expanded in the transformed space to cover the full canvas.\r\n  if (!isCircle && rx !== ry) {\r\n    const sx = radius / rx;\r\n    const sy = radius / ry;\r\n    ctx.fillRect(cx * (1 - sx), cy * (1 - sy), width * sx, height * sy);\r\n  } else {\r\n    ctx.fillRect(0, 0, width, height);\r\n  }\r\n  ctx.restore();\r\n\r\n  return canvas.toDataURL(\"image/png\");\r\n}\r\n\r\n/**\r\n * Parse a color stop like \"red 50%\" into color and position.\r\n * Handles modern CSS color syntax with spaces (e.g. \"hsl(120deg 50% 50%) 75%\")\r\n * by only looking for a position % after the last closing parenthesis.\r\n */\r\nfunction parseColorStop(\r\n  stop: string,\r\n  index: number,\r\n  total: number,\r\n): { color: string; position: number } {\r\n  // Look for a trailing percentage after any function parens\r\n  const lastParen = stop.lastIndexOf(\")\");\r\n  const tail = lastParen >= 0 ? stop.slice(lastParen + 1) : stop;\r\n  const posMatch = tail.match(/\\s+([\\d.]+%)\\s*$/);\r\n  if (posMatch) {\r\n    const posStr = posMatch[1]!;\r\n    const colorEnd = stop.length - posMatch[0].length;\r\n    return {\r\n      color: stop.slice(0, colorEnd).trim(),\r\n      position: parseFloat(posStr) / 100,\r\n    };\r\n  }\r\n  // No parens: try simple \"color position\" format (e.g. \"red 50%\")\r\n  if (lastParen < 0) {\r\n    const spaceIdx = stop.lastIndexOf(\" \");\r\n    if (spaceIdx > 0 && stop.slice(spaceIdx).match(/[\\d.]+%/)) {\r\n      return {\r\n        color: stop.slice(0, spaceIdx).trim(),\r\n        position: parseFloat(stop.slice(spaceIdx)) / 100,\r\n      };\r\n    }\r\n  }\r\n  return {\r\n    color: stop,\r\n    position: total > 1 ? index / (total - 1) : 0,\r\n  };\r\n}\r\n\r\n/** Split gradient arguments respecting nested parentheses */\r\nfunction splitGradientArgs(str: string): string[] {\r\n  const parts: string[] = [];\r\n  let depth = 0;\r\n  let current = \"\";\r\n\r\n  for (const char of str) {\r\n    if (char === \"(\") depth++;\r\n    else if (char === \")\") depth--;\r\n\r\n    if (char === \",\" && depth === 0) {\r\n      parts.push(current);\r\n      current = \"\";\r\n    } else {\r\n      current += char;\r\n    }\r\n  }\r\n  if (current) parts.push(current);\r\n  return parts;\r\n}\r\n\r\nfunction directionToAngle(dir: string): number {\r\n  const map: Record<string, number> = {\r\n    \"to top\": 0,\r\n    \"to right\": 90,\r\n    \"to bottom\": 180,\r\n    \"to left\": 270,\r\n    \"to top right\": 45,\r\n    \"to top left\": 315,\r\n    \"to bottom right\": 135,\r\n    \"to bottom left\": 225,\r\n  };\r\n  return map[dir] ?? 180;\r\n}\r\n\r\nfunction parseAngle(value: string): number {\r\n  if (value.endsWith(\"deg\")) return parseFloat(value);\r\n  if (value.endsWith(\"rad\")) return (parseFloat(value) * 180) / Math.PI;\r\n  if (value.endsWith(\"turn\")) return parseFloat(value) * 360;\r\n  if (value.endsWith(\"grad\")) return parseFloat(value) * 0.9;\r\n  return parseFloat(value);\r\n}\r\n\r\n/** Parse a CSS length (px) or percentage relative to a container dimension */\r\nfunction parseLengthOrPercent(value: string, containerSize: number): number | null {\r\n  if (value === \"center\") return containerSize / 2;\r\n  if (value === \"left\" || value === \"top\") return 0;\r\n  if (value === \"right\" || value === \"bottom\") return containerSize;\r\n  if (value.endsWith(\"%\")) return (parseFloat(value) / 100) * containerSize;\r\n  const num = parseFloat(value);\r\n  return isNaN(num) ? null : num;\r\n}\r\n","const IMAGE_TIMEOUT_MS = 10_000;\r\nconst MAX_CANVAS_DIM = 4096;\r\n\r\n/**\r\n * Convert an image URL to a data URL by drawing it onto a canvas.\r\n * Falls back to the original URL if CORS prevents reading or loading times out.\r\n */\r\nexport async function imageToDataUrl(url: string): Promise<string> {\r\n  // Already a data URL\r\n  if (url.startsWith(\"data:\")) return url;\r\n\r\n  return new Promise((resolve) => {\r\n    const img = new Image();\r\n    img.crossOrigin = \"anonymous\";\r\n\r\n    const timer = setTimeout(() => {\r\n      console.warn(`dom2svg: Image load timed out after ${IMAGE_TIMEOUT_MS}ms, using original URL: ${url}`);\r\n      img.onload = null;\r\n      img.onerror = null;\r\n      resolve(url);\r\n    }, IMAGE_TIMEOUT_MS);\r\n\r\n    img.onload = () => {\r\n      clearTimeout(timer);\r\n      try {\r\n        const canvas = document.createElement(\"canvas\");\r\n        // Cap dimensions to prevent OOM on very large images\r\n        let w = img.naturalWidth;\r\n        let h = img.naturalHeight;\r\n        if (w > MAX_CANVAS_DIM || h > MAX_CANVAS_DIM) {\r\n          const scale = MAX_CANVAS_DIM / Math.max(w, h);\r\n          w = Math.round(w * scale);\r\n          h = Math.round(h * scale);\r\n        }\r\n        canvas.width = w;\r\n        canvas.height = h;\r\n        const ctx = canvas.getContext(\"2d\");\r\n        if (ctx) {\r\n          ctx.drawImage(img, 0, 0, w, h);\r\n          resolve(canvas.toDataURL(\"image/png\"));\r\n        } else {\r\n          resolve(url);\r\n        }\r\n      } catch {\r\n        console.warn(`dom2svg: CORS prevented inlining image, external URL will remain in SVG: ${url}`);\r\n        resolve(url);\r\n      }\r\n    };\r\n    img.onerror = () => {\r\n      clearTimeout(timer);\r\n      console.warn(`dom2svg: Failed to load image, external URL will remain in SVG: ${url}`);\r\n      resolve(url);\r\n    };\r\n    img.src = url;\r\n  });\r\n}\r\n\r\n/** Extract URL from css url() value */\r\nexport function extractUrlFromCss(value: string): string | null {\r\n  const match = value.match(/url\\([\"']?([^\"')]+)[\"']?\\)/);\r\n  return match?.[1] ?? null;\r\n}\r\n\r\n/** Convert a canvas element to a data URL */\r\nexport function canvasToDataUrl(canvas: HTMLCanvasElement): string {\r\n  try {\r\n    return canvas.toDataURL(\"image/png\");\r\n  } catch {\r\n    return \"\";\r\n  }\r\n}\r\n","import type { TransformFunction } from \"../types.js\";\r\n\r\n/**\r\n * Parse a CSS transform string into a list of transform functions.\r\n * Supports: matrix, translate, translateX, translateY, scale, scaleX, scaleY,\r\n * rotate, skewX, skewY.\r\n */\r\nexport function parseTransform(value: string): TransformFunction[] {\r\n  if (!value || value === \"none\") return [];\r\n\r\n  const functions: TransformFunction[] = [];\r\n  const regex = /(\\w+)\\(([^)]+)\\)/g;\r\n  let match: RegExpExecArray | null;\r\n\r\n  while ((match = regex.exec(value)) !== null) {\r\n    const name = match[1]!;\r\n    const args = match[2]!.split(\",\").map((s) => s.trim());\r\n\r\n    switch (name) {\r\n      case \"matrix\": {\r\n        const vals = args.map(parseFloat);\r\n        if (vals.length === 6) {\r\n          functions.push({\r\n            type: \"matrix\",\r\n            values: vals as [number, number, number, number, number, number],\r\n          });\r\n        }\r\n        break;\r\n      }\r\n      case \"translate\": {\r\n        const x = parseLengthValue(args[0]!);\r\n        const y = args[1] ? parseLengthValue(args[1]) : 0;\r\n        functions.push({ type: \"translate\", x, y });\r\n        break;\r\n      }\r\n      case \"translateX\": {\r\n        functions.push({ type: \"translate\", x: parseLengthValue(args[0]!), y: 0 });\r\n        break;\r\n      }\r\n      case \"translateY\": {\r\n        functions.push({ type: \"translate\", x: 0, y: parseLengthValue(args[0]!) });\r\n        break;\r\n      }\r\n      case \"scale\": {\r\n        const sx = parseFloat(args[0]!);\r\n        const sy = args[1] ? parseFloat(args[1]) : sx;\r\n        functions.push({ type: \"scale\", x: sx, y: sy });\r\n        break;\r\n      }\r\n      case \"scaleX\": {\r\n        functions.push({ type: \"scale\", x: parseFloat(args[0]!), y: 1 });\r\n        break;\r\n      }\r\n      case \"scaleY\": {\r\n        functions.push({ type: \"scale\", x: 1, y: parseFloat(args[0]!) });\r\n        break;\r\n      }\r\n      case \"rotate\": {\r\n        functions.push({ type: \"rotate\", angle: parseAngleValue(args[0]!) });\r\n        break;\r\n      }\r\n      case \"skewX\": {\r\n        functions.push({ type: \"skewX\", angle: parseAngleValue(args[0]!) });\r\n        break;\r\n      }\r\n      case \"skewY\": {\r\n        functions.push({ type: \"skewY\", angle: parseAngleValue(args[0]!) });\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return functions;\r\n}\r\n\r\nfunction parseLengthValue(value: string): number {\r\n  return parseFloat(value) || 0;\r\n}\r\n\r\nfunction parseAngleValue(value: string): number {\r\n  value = value.trim();\r\n  if (value.endsWith(\"rad\")) return (parseFloat(value) * 180) / Math.PI;\r\n  if (value.endsWith(\"turn\")) return parseFloat(value) * 360;\r\n  if (value.endsWith(\"grad\")) return parseFloat(value) * 0.9;\r\n  // Default: degrees\r\n  return parseFloat(value) || 0;\r\n}\r\n","import type { MatrixTuple } from \"../types.js\";\r\n\r\n/**\r\n * 2D affine transform matrix operations.\r\n * Matrix layout: [a, b, c, d, e, f]\r\n *\r\n * | a c e |\r\n * | b d f |\r\n * | 0 0 1 |\r\n */\r\n\r\n/** Identity matrix */\r\nexport function identity(): MatrixTuple {\r\n  return [1, 0, 0, 1, 0, 0];\r\n}\r\n\r\n/** Multiply two matrices: A * B */\r\nexport function multiply(a: MatrixTuple, b: MatrixTuple): MatrixTuple {\r\n  return [\r\n    a[0] * b[0] + a[2] * b[1],\r\n    a[1] * b[0] + a[3] * b[1],\r\n    a[0] * b[2] + a[2] * b[3],\r\n    a[1] * b[2] + a[3] * b[3],\r\n    a[0] * b[4] + a[2] * b[5] + a[4],\r\n    a[1] * b[4] + a[3] * b[5] + a[5],\r\n  ];\r\n}\r\n\r\n/** Create a translation matrix */\r\nexport function translate(tx: number, ty: number): MatrixTuple {\r\n  return [1, 0, 0, 1, tx, ty];\r\n}\r\n\r\n/** Create a scale matrix */\r\nexport function scale(sx: number, sy: number): MatrixTuple {\r\n  return [sx, 0, 0, sy, 0, 0];\r\n}\r\n\r\n/** Create a rotation matrix (angle in degrees) */\r\nexport function rotate(angleDeg: number): MatrixTuple {\r\n  const rad = (angleDeg * Math.PI) / 180;\r\n  const cos = Math.cos(rad);\r\n  const sin = Math.sin(rad);\r\n  return [cos, sin, -sin, cos, 0, 0];\r\n}\r\n\r\n/** Create a skewX matrix (angle in degrees) */\r\nexport function skewX(angleDeg: number): MatrixTuple {\r\n  const rad = (angleDeg * Math.PI) / 180;\r\n  return [1, 0, Math.tan(rad), 1, 0, 0];\r\n}\r\n\r\n/** Create a skewY matrix (angle in degrees) */\r\nexport function skewY(angleDeg: number): MatrixTuple {\r\n  const rad = (angleDeg * Math.PI) / 180;\r\n  return [1, Math.tan(rad), 0, 1, 0, 0];\r\n}\r\n\r\n/** Compute the inverse of a matrix. Returns null if singular. */\r\nexport function inverse(m: MatrixTuple): MatrixTuple | null {\r\n  const det = m[0] * m[3] - m[1] * m[2];\r\n  if (Math.abs(det) < 1e-10) return null;\r\n\r\n  const invDet = 1 / det;\r\n  return [\r\n    m[3] * invDet,\r\n    -m[1] * invDet,\r\n    -m[2] * invDet,\r\n    m[0] * invDet,\r\n    (m[2] * m[5] - m[3] * m[4]) * invDet,\r\n    (m[1] * m[4] - m[0] * m[5]) * invDet,\r\n  ];\r\n}\r\n\r\n/** Check if a matrix is the identity matrix */\r\nexport function isIdentity(m: MatrixTuple): boolean {\r\n  return (\r\n    Math.abs(m[0] - 1) < 1e-10 &&\r\n    Math.abs(m[1]) < 1e-10 &&\r\n    Math.abs(m[2]) < 1e-10 &&\r\n    Math.abs(m[3] - 1) < 1e-10 &&\r\n    Math.abs(m[4]) < 1e-10 &&\r\n    Math.abs(m[5]) < 1e-10\r\n  );\r\n}\r\n\r\n/** Format matrix as SVG transform attribute value */\r\nexport function toSvgTransform(m: MatrixTuple): string {\r\n  return `matrix(${m.map((v) => v.toFixed(6)).join(\",\")})`;\r\n}\r\n","import type { TransformFunction, MatrixTuple } from \"../types.js\";\r\nimport { parseTransform } from \"./parse.js\";\r\nimport * as mat from \"./matrix.js\";\r\n\r\n/**\r\n * Convert a CSS transform string to an SVG transform attribute value.\r\n * Returns null if no transform or identity transform.\r\n */\r\nexport function cssTransformToSvg(\r\n  cssTransform: string,\r\n  transformOrigin: string,\r\n  box: { x: number; y: number; width: number; height: number },\r\n): string | null {\r\n  const functions = parseTransform(cssTransform);\r\n  if (functions.length === 0) return null;\r\n\r\n  // Parse transform-origin\r\n  const [ox, oy] = parseTransformOrigin(transformOrigin, box);\r\n\r\n  // Build the combined matrix\r\n  let result = mat.identity();\r\n\r\n  // Move origin\r\n  result = mat.multiply(result, mat.translate(ox, oy));\r\n\r\n  // Apply each transform function\r\n  for (const fn of functions) {\r\n    result = mat.multiply(result, transformFunctionToMatrix(fn));\r\n  }\r\n\r\n  // Move origin back\r\n  result = mat.multiply(result, mat.translate(-ox, -oy));\r\n\r\n  if (mat.isIdentity(result)) return null;\r\n\r\n  return mat.toSvgTransform(result);\r\n}\r\n\r\n/** Convert a single TransformFunction to a matrix */\r\nfunction transformFunctionToMatrix(fn: TransformFunction): MatrixTuple {\r\n  switch (fn.type) {\r\n    case \"matrix\":\r\n      return fn.values;\r\n    case \"translate\":\r\n      return mat.translate(fn.x, fn.y);\r\n    case \"scale\":\r\n      return mat.scale(fn.x, fn.y);\r\n    case \"rotate\":\r\n      return mat.rotate(fn.angle);\r\n    case \"skewX\":\r\n      return mat.skewX(fn.angle);\r\n    case \"skewY\":\r\n      return mat.skewY(fn.angle);\r\n  }\r\n}\r\n\r\n/** Parse CSS transform-origin into absolute coordinates */\r\nfunction parseTransformOrigin(\r\n  origin: string,\r\n  box: { x: number; y: number; width: number; height: number },\r\n): [number, number] {\r\n  const parts = origin.split(/\\s+/);\r\n  const x = parseOriginValue(parts[0] ?? \"50%\", box.width, box.x);\r\n  const y = parseOriginValue(parts[1] ?? \"50%\", box.height, box.y);\r\n  return [x, y];\r\n}\r\n\r\nfunction parseOriginValue(\r\n  value: string,\r\n  size: number,\r\n  offset: number,\r\n): number {\r\n  if (value === \"left\" || value === \"top\") return offset;\r\n  if (value === \"right\" || value === \"bottom\") return offset + size;\r\n  if (value === \"center\") return offset + size / 2;\r\n  if (value.endsWith(\"%\")) {\r\n    return offset + (parseFloat(value) / 100) * size;\r\n  }\r\n  return offset + parseFloat(value);\r\n}\r\n","import type { RenderContext } from \"../types.js\";\r\nimport { createSvgElement, setAttributes } from \"../utils/dom.js\";\r\n\r\n/** A parsed CSS filter function */\r\ninterface CssFilterFunction {\r\n  name: string;\r\n  args: string;\r\n}\r\n\r\n/**\r\n * Parse a CSS filter value and create an SVG <filter> with the equivalent primitives.\r\n * Supports: blur, brightness, contrast, drop-shadow, grayscale, hue-rotate,\r\n *           invert, opacity, saturate, sepia.\r\n * Returns the filter ID, or null if no recognized filter functions found.\r\n */\r\nexport function createSvgFilter(\r\n  filterValue: string,\r\n  ctx: RenderContext,\r\n): string | null {\r\n  const functions = parseCssFilterFunctions(filterValue);\r\n  if (functions.length === 0) return null;\r\n\r\n  const id = ctx.idGenerator.next(\"filter\");\r\n  const filter = createSvgElement(ctx.svgDocument, \"filter\");\r\n  setAttributes(filter, {\r\n    id,\r\n    x: \"-50%\",\r\n    y: \"-50%\",\r\n    width: \"200%\",\r\n    height: \"200%\",\r\n  });\r\n\r\n  let hasAny = false;\r\n\r\n  for (const fn of functions) {\r\n    const primitives = createFilterPrimitives(fn, ctx);\r\n    for (const prim of primitives) {\r\n      filter.appendChild(prim);\r\n      hasAny = true;\r\n    }\r\n  }\r\n\r\n  if (!hasAny) return null;\r\n\r\n  ctx.defs.appendChild(filter);\r\n  return id;\r\n}\r\n\r\n/** Parse a numeric value that may have a % suffix. Returns a ratio (1 = 100%). */\r\nfunction parseFilterAmount(raw: string): number {\r\n  const trimmed = raw.trim();\r\n  if (trimmed.endsWith(\"%\")) {\r\n    return (parseFloat(trimmed) || 0) / 100;\r\n  }\r\n  return parseFloat(trimmed) || 0;\r\n}\r\n\r\n/** Parse an angle value, returning degrees. Handles deg, rad, grad, turn. */\r\nfunction parseAngle(raw: string): number {\r\n  const trimmed = raw.trim();\r\n  if (trimmed.endsWith(\"rad\")) return (parseFloat(trimmed) || 0) * (180 / Math.PI);\r\n  if (trimmed.endsWith(\"grad\")) return (parseFloat(trimmed) || 0) * 0.9;\r\n  if (trimmed.endsWith(\"turn\")) return (parseFloat(trimmed) || 0) * 360;\r\n  // deg or bare number\r\n  return parseFloat(trimmed) || 0;\r\n}\r\n\r\n/** Create SVG filter primitive(s) for a single CSS filter function */\r\nfunction createFilterPrimitives(\r\n  fn: CssFilterFunction,\r\n  ctx: RenderContext,\r\n): SVGElement[] {\r\n  switch (fn.name) {\r\n    case \"blur\": {\r\n      // CSS blur() value IS the stdDeviation directly\r\n      const radius = parseFloat(fn.args) || 0;\r\n      const blur = createSvgElement(ctx.svgDocument, \"feGaussianBlur\");\r\n      setAttributes(blur, { stdDeviation: radius });\r\n      return [blur];\r\n    }\r\n\r\n    case \"brightness\": {\r\n      const amount = parseFilterAmount(fn.args);\r\n      return [createComponentTransfer(ctx, { slope: amount })];\r\n    }\r\n\r\n    case \"contrast\": {\r\n      const amount = parseFilterAmount(fn.args);\r\n      const intercept = 0.5 - 0.5 * amount;\r\n      return [createComponentTransfer(ctx, { slope: amount, intercept })];\r\n    }\r\n\r\n    case \"drop-shadow\": {\r\n      const parsed = parseDropShadow(`drop-shadow(${fn.args})`);\r\n      if (!parsed) return [];\r\n      const shadow = createSvgElement(ctx.svgDocument, \"feDropShadow\");\r\n      setAttributes(shadow, {\r\n        dx: parsed.offsetX,\r\n        dy: parsed.offsetY,\r\n        stdDeviation: parsed.blur / 2,\r\n        \"flood-color\": parsed.color,\r\n        \"flood-opacity\": 1,\r\n      });\r\n      return [shadow];\r\n    }\r\n\r\n    case \"grayscale\": {\r\n      const amount = parseFilterAmount(fn.args);\r\n      const s = Math.max(0, Math.min(1, 1 - amount));\r\n      const matrix = createSvgElement(ctx.svgDocument, \"feColorMatrix\");\r\n      setAttributes(matrix, { type: \"saturate\", values: s });\r\n      return [matrix];\r\n    }\r\n\r\n    case \"hue-rotate\": {\r\n      const degrees = parseAngle(fn.args);\r\n      const matrix = createSvgElement(ctx.svgDocument, \"feColorMatrix\");\r\n      setAttributes(matrix, { type: \"hueRotate\", values: degrees });\r\n      return [matrix];\r\n    }\r\n\r\n    case \"invert\": {\r\n      const amount = parseFilterAmount(fn.args);\r\n      const lo = amount;\r\n      const hi = 1 - amount;\r\n      return [createComponentTransfer(ctx, {\r\n        type: \"table\",\r\n        tableValues: `${lo} ${hi}`,\r\n      })];\r\n    }\r\n\r\n    case \"opacity\": {\r\n      const amount = parseFilterAmount(fn.args);\r\n      const transfer = createSvgElement(ctx.svgDocument, \"feComponentTransfer\");\r\n      const funcA = createSvgElement(ctx.svgDocument, \"feFuncA\");\r\n      setAttributes(funcA, { type: \"linear\", slope: amount, intercept: 0 });\r\n      transfer.appendChild(funcA);\r\n      return [transfer];\r\n    }\r\n\r\n    case \"saturate\": {\r\n      const amount = parseFilterAmount(fn.args);\r\n      const matrix = createSvgElement(ctx.svgDocument, \"feColorMatrix\");\r\n      setAttributes(matrix, { type: \"saturate\", values: amount });\r\n      return [matrix];\r\n    }\r\n\r\n    case \"sepia\": {\r\n      const amount = Math.max(0, Math.min(1, parseFilterAmount(fn.args)));\r\n      // Interpolate between identity matrix and sepia matrix\r\n      const a = amount;\r\n      const b = 1 - amount;\r\n      const values = [\r\n        b + a * 0.393, a * 0.769, a * 0.189, 0, 0,\r\n        a * 0.349, b + a * 0.686, a * 0.168, 0, 0,\r\n        a * 0.272, a * 0.534, b + a * 0.131, 0, 0,\r\n        0, 0, 0, 1, 0,\r\n      ].map(v => v.toFixed(4)).join(\" \");\r\n      const matrix = createSvgElement(ctx.svgDocument, \"feColorMatrix\");\r\n      setAttributes(matrix, { type: \"matrix\", values });\r\n      return [matrix];\r\n    }\r\n\r\n    default:\r\n      return [];\r\n  }\r\n}\r\n\r\n/** Create an feComponentTransfer for RGB channels with uniform settings */\r\nfunction createComponentTransfer(\r\n  ctx: RenderContext,\r\n  opts: { slope?: number; intercept?: number; type?: string; tableValues?: string },\r\n): SVGElement {\r\n  const transfer = createSvgElement(ctx.svgDocument, \"feComponentTransfer\");\r\n  for (const channel of [\"feFuncR\", \"feFuncG\", \"feFuncB\"] as const) {\r\n    const func = createSvgElement(ctx.svgDocument, channel);\r\n    if (opts.type === \"table\" && opts.tableValues) {\r\n      setAttributes(func, { type: \"table\", tableValues: opts.tableValues });\r\n    } else {\r\n      const attrs: Record<string, string | number> = {\r\n        type: \"linear\",\r\n        slope: opts.slope ?? 1,\r\n      };\r\n      if (opts.intercept !== undefined) attrs.intercept = opts.intercept;\r\n      setAttributes(func, attrs);\r\n    }\r\n    transfer.appendChild(func);\r\n  }\r\n  return transfer;\r\n}\r\n\r\n/**\r\n * Extract individual CSS filter functions from a filter value string.\r\n * Handles nested parentheses (e.g. drop-shadow with rgba()).\r\n */\r\nexport function parseCssFilterFunctions(value: string): CssFilterFunction[] {\r\n  const results: CssFilterFunction[] = [];\r\n  const regex = /([a-z-]+)\\(/gi;\r\n  let match: RegExpExecArray | null;\r\n\r\n  while ((match = regex.exec(value)) !== null) {\r\n    const name = match[1]!;\r\n    const argsStart = match.index + match[0].length;\r\n\r\n    // Find matching closing paren, respecting nesting\r\n    let depth = 1;\r\n    let i = argsStart;\r\n    for (; i < value.length && depth > 0; i++) {\r\n      if (value[i] === \"(\") depth++;\r\n      else if (value[i] === \")\") depth--;\r\n    }\r\n\r\n    const args = value.slice(argsStart, i - 1).trim();\r\n    results.push({ name: name.toLowerCase(), args });\r\n\r\n    // Advance regex past this function\r\n    regex.lastIndex = i;\r\n  }\r\n\r\n  return results;\r\n}\r\n\r\nexport interface DropShadow {\r\n  offsetX: number;\r\n  offsetY: number;\r\n  blur: number;\r\n  color: string;\r\n}\r\n\r\n/** @internal Exported for testing */\r\nexport function parseDropShadow(value: string): DropShadow | null {\r\n  // Match drop-shadow(...) respecting nested parentheses (e.g. rgba())\r\n  const startIdx = value.indexOf(\"drop-shadow(\");\r\n  if (startIdx === -1) return null;\r\n\r\n  const argsStart = startIdx + \"drop-shadow(\".length;\r\n  let depth = 1;\r\n  let argsEnd = argsStart;\r\n  for (let i = argsStart; i < value.length && depth > 0; i++) {\r\n    if (value[i] === \"(\") depth++;\r\n    else if (value[i] === \")\") depth--;\r\n    if (depth > 0) argsEnd = i + 1;\r\n  }\r\n\r\n  const args = value.slice(argsStart, argsEnd).trim();\r\n  if (!args) return null;\r\n\r\n  // Parse: offsetX offsetY [blur] [color]\r\n  // Color can be at start or end, with various formats\r\n  const parts: string[] = [];\r\n  let current = \"\";\r\n  let parenDepth = 0;\r\n\r\n  for (const char of args) {\r\n    if (char === \"(\") parenDepth++;\r\n    else if (char === \")\") parenDepth--;\r\n\r\n    if (char === \" \" && parenDepth === 0 && current) {\r\n      parts.push(current);\r\n      current = \"\";\r\n    } else {\r\n      current += char;\r\n    }\r\n  }\r\n  if (current) parts.push(current);\r\n\r\n  if (parts.length < 2) return null;\r\n\r\n  // Find numeric values and color\r\n  const numericParts: number[] = [];\r\n  let color = \"rgba(0,0,0,0.3)\";\r\n\r\n  for (const part of parts) {\r\n    const num = parseFloat(part);\r\n    if (!isNaN(num) && (part.endsWith(\"px\") || part.match(/^-?[\\d.]+$/))) {\r\n      numericParts.push(num);\r\n    } else {\r\n      color = part;\r\n    }\r\n  }\r\n\r\n  return {\r\n    offsetX: numericParts[0] ?? 0,\r\n    offsetY: numericParts[1] ?? 0,\r\n    blur: numericParts[2] ?? 0,\r\n    color,\r\n  };\r\n}\r\n","import type { RenderContext, BoxGeometry, BorderRadii } from \"../types.js\";\r\nimport { createSvgElement, setAttributes } from \"../utils/dom.js\";\r\nimport { buildRoundedRectPath } from \"../utils/geometry.js\";\r\nimport { hasRadius, isUniformRadius } from \"../core/styles.js\";\r\n\r\nexport interface BoxShadow {\r\n  inset: boolean;\r\n  offsetX: number;\r\n  offsetY: number;\r\n  blur: number;\r\n  spread: number;\r\n  color: string;\r\n}\r\n\r\n/**\r\n * Parse a CSS box-shadow value into an array of BoxShadow objects.\r\n * Supports multiple shadows, inset, spread, blur, and color in various formats.\r\n */\r\nexport function parseBoxShadows(value: string): BoxShadow[] {\r\n  if (!value || value === \"none\") return [];\r\n\r\n  const shadows: BoxShadow[] = [];\r\n  const parts = splitTopLevelCommas(value);\r\n\r\n  for (const part of parts) {\r\n    const shadow = parseSingleShadow(part.trim());\r\n    if (shadow) shadows.push(shadow);\r\n  }\r\n\r\n  return shadows;\r\n}\r\n\r\n/** Split on commas at depth 0 (respecting parentheses) */\r\nfunction splitTopLevelCommas(str: string): string[] {\r\n  const parts: string[] = [];\r\n  let depth = 0;\r\n  let current = \"\";\r\n\r\n  for (const char of str) {\r\n    if (char === \"(\") depth++;\r\n    else if (char === \")\") depth--;\r\n\r\n    if (char === \",\" && depth === 0) {\r\n      parts.push(current);\r\n      current = \"\";\r\n    } else {\r\n      current += char;\r\n    }\r\n  }\r\n  if (current) parts.push(current);\r\n  return parts;\r\n}\r\n\r\n/** Parse a single box-shadow value */\r\nfunction parseSingleShadow(value: string): BoxShadow | null {\r\n  let inset = false;\r\n  let working = value;\r\n\r\n  // Check for inset keyword\r\n  if (working.startsWith(\"inset \")) {\r\n    inset = true;\r\n    working = working.slice(6).trim();\r\n  } else if (working.endsWith(\" inset\")) {\r\n    inset = true;\r\n    working = working.slice(0, -6).trim();\r\n  }\r\n\r\n  // Tokenize respecting parentheses\r\n  const tokens: string[] = [];\r\n  let current = \"\";\r\n  let depth = 0;\r\n\r\n  for (const char of working) {\r\n    if (char === \"(\") depth++;\r\n    else if (char === \")\") depth--;\r\n\r\n    if (char === \" \" && depth === 0 && current) {\r\n      tokens.push(current);\r\n      current = \"\";\r\n    } else {\r\n      current += char;\r\n    }\r\n  }\r\n  if (current) tokens.push(current);\r\n\r\n  // Separate numeric (px) tokens from color tokens\r\n  const numericValues: number[] = [];\r\n  const colorParts: string[] = [];\r\n\r\n  for (const token of tokens) {\r\n    const num = parseFloat(token);\r\n    if (!isNaN(num) && (token.endsWith(\"px\") || token.match(/^-?[\\d.]+$/))) {\r\n      numericValues.push(num);\r\n    } else {\r\n      colorParts.push(token);\r\n    }\r\n  }\r\n\r\n  if (numericValues.length < 2) return null;\r\n\r\n  return {\r\n    inset,\r\n    offsetX: numericValues[0]!,\r\n    offsetY: numericValues[1]!,\r\n    blur: numericValues[2] ?? 0,\r\n    spread: numericValues[3] ?? 0,\r\n    color: colorParts.join(\" \") || \"rgba(0, 0, 0, 0.3)\",\r\n  };\r\n}\r\n\r\n/**\r\n * Render box-shadows as SVG elements. Non-inset shadows use SVG filters\r\n * for Gaussian blur; inset shadows are approximated similarly.\r\n * Returns an array of SVG elements to prepend before the element's content.\r\n */\r\nexport function renderBoxShadows(\r\n  shadows: BoxShadow[],\r\n  box: BoxGeometry,\r\n  radii: BorderRadii,\r\n  ctx: RenderContext,\r\n  group: SVGGElement,\r\n): void {\r\n  // CSS renders shadows in reverse order (first shadow = topmost)\r\n  for (let i = shadows.length - 1; i >= 0; i--) {\r\n    const shadow = shadows[i]!;\r\n    if (shadow.inset) {\r\n      renderInsetShadow(shadow, box, radii, ctx, group);\r\n    } else {\r\n      renderOuterShadow(shadow, box, radii, ctx, group);\r\n    }\r\n  }\r\n}\r\n\r\nfunction renderOuterShadow(\r\n  shadow: BoxShadow,\r\n  box: BoxGeometry,\r\n  radii: BorderRadii,\r\n  ctx: RenderContext,\r\n  group: SVGGElement,\r\n): void {\r\n  // Expand box by spread\r\n  const spreadBox: BoxGeometry = {\r\n    x: box.x + shadow.offsetX - shadow.spread,\r\n    y: box.y + shadow.offsetY - shadow.spread,\r\n    width: box.width + shadow.spread * 2,\r\n    height: box.height + shadow.spread * 2,\r\n  };\r\n\r\n  // Expand radii by spread\r\n  const spreadRadii = expandRadii(radii, shadow.spread);\r\n\r\n  // Create shape\r\n  const shape = createShadowShape(spreadBox, spreadRadii, ctx);\r\n  shape.setAttribute(\"fill\", shadow.color);\r\n\r\n  if (shadow.blur > 0) {\r\n    // Create SVG filter for blur\r\n    const filterId = ctx.idGenerator.next(\"shadow\");\r\n    const filter = createSvgElement(ctx.svgDocument, \"filter\");\r\n    const margin = shadow.blur * 2 + Math.abs(shadow.offsetX) + Math.abs(shadow.offsetY) + shadow.spread;\r\n    // Guard against zero/tiny dimensions to avoid division-by-zero or huge percentages\r\n    const safeW = Math.max(spreadBox.width, 1);\r\n    const safeH = Math.max(spreadBox.height, 1);\r\n    setAttributes(filter, {\r\n      id: filterId,\r\n      x: `-${((margin / safeW) * 100 + 10).toFixed(0)}%`,\r\n      y: `-${((margin / safeH) * 100 + 10).toFixed(0)}%`,\r\n      width: `${(200 + (margin / safeW) * 200 + 20).toFixed(0)}%`,\r\n      height: `${(200 + (margin / safeH) * 200 + 20).toFixed(0)}%`,\r\n    });\r\n\r\n    const feGaussianBlur = createSvgElement(ctx.svgDocument, \"feGaussianBlur\");\r\n    setAttributes(feGaussianBlur, {\r\n      in: \"SourceGraphic\",\r\n      stdDeviation: shadow.blur / 2,\r\n    });\r\n    filter.appendChild(feGaussianBlur);\r\n    ctx.defs.appendChild(filter);\r\n\r\n    shape.setAttribute(\"filter\", `url(#${filterId})`);\r\n  }\r\n\r\n  // Insert shadow before existing children (shadows render behind content)\r\n  group.insertBefore(shape, group.firstChild);\r\n}\r\n\r\nfunction renderInsetShadow(\r\n  shadow: BoxShadow,\r\n  box: BoxGeometry,\r\n  radii: BorderRadii,\r\n  ctx: RenderContext,\r\n  group: SVGGElement,\r\n): void {\r\n  // For inset shadows, we draw a filled ring clipped to the box.\r\n  // The ring is a large rect minus the inner shadow shape.\r\n  const clipId = ctx.idGenerator.next(\"inset-clip\");\r\n  const clipPath = createSvgElement(ctx.svgDocument, \"clipPath\");\r\n  clipPath.setAttribute(\"id\", clipId);\r\n  const clipShape = createShadowShape(box, radii, ctx);\r\n  clipPath.appendChild(clipShape);\r\n  ctx.defs.appendChild(clipPath);\r\n\r\n  // Inner shape (shrunk by spread, offset)\r\n  const innerBox: BoxGeometry = {\r\n    x: box.x + shadow.offsetX + shadow.spread,\r\n    y: box.y + shadow.offsetY + shadow.spread,\r\n    width: Math.max(0, box.width - shadow.spread * 2),\r\n    height: Math.max(0, box.height - shadow.spread * 2),\r\n  };\r\n  const innerRadii = expandRadii(radii, -shadow.spread);\r\n\r\n  // Use a large outer rect and inner cutout path\r\n  const g = createSvgElement(ctx.svgDocument, \"g\") as SVGGElement;\r\n  g.setAttribute(\"clip-path\", `url(#${clipId})`);\r\n\r\n  // Large surrounding fill\r\n  const outerRect = createSvgElement(ctx.svgDocument, \"rect\");\r\n  const pad = shadow.blur * 3 + Math.abs(shadow.offsetX) + Math.abs(shadow.offsetY) + 100;\r\n  setAttributes(outerRect, {\r\n    x: box.x - pad,\r\n    y: box.y - pad,\r\n    width: box.width + pad * 2,\r\n    height: box.height + pad * 2,\r\n    fill: shadow.color,\r\n  });\r\n\r\n  // Inner cutout\r\n  const innerShape = createShadowShape(innerBox, innerRadii, ctx);\r\n  innerShape.setAttribute(\"fill\", shadow.color);\r\n\r\n  // Use fill-rule evenodd with combined path for cutout effect\r\n  // Simpler: just use the inner shape as a mask\r\n  const maskId = ctx.idGenerator.next(\"inset-mask\");\r\n  const mask = createSvgElement(ctx.svgDocument, \"mask\");\r\n  mask.setAttribute(\"id\", maskId);\r\n\r\n  const maskWhite = createSvgElement(ctx.svgDocument, \"rect\");\r\n  setAttributes(maskWhite, { x: box.x - pad, y: box.y - pad, width: box.width + pad * 2, height: box.height + pad * 2, fill: \"white\" });\r\n  const maskBlack = createShadowShape(innerBox, innerRadii, ctx);\r\n  maskBlack.setAttribute(\"fill\", \"black\");\r\n  mask.appendChild(maskWhite);\r\n  mask.appendChild(maskBlack);\r\n  ctx.defs.appendChild(mask);\r\n\r\n  outerRect.setAttribute(\"mask\", `url(#${maskId})`);\r\n\r\n  if (shadow.blur > 0) {\r\n    const filterId = ctx.idGenerator.next(\"inset-blur\");\r\n    const filter = createSvgElement(ctx.svgDocument, \"filter\");\r\n    setAttributes(filter, { id: filterId, x: \"-50%\", y: \"-50%\", width: \"200%\", height: \"200%\" });\r\n    const feBlur = createSvgElement(ctx.svgDocument, \"feGaussianBlur\");\r\n    setAttributes(feBlur, { in: \"SourceGraphic\", stdDeviation: shadow.blur / 2 });\r\n    filter.appendChild(feBlur);\r\n    ctx.defs.appendChild(filter);\r\n    outerRect.setAttribute(\"filter\", `url(#${filterId})`);\r\n  }\r\n\r\n  g.appendChild(outerRect);\r\n  group.insertBefore(g, group.firstChild);\r\n}\r\n\r\n/** Create a shape element matching the box (rect or rounded-rect path) */\r\nfunction createShadowShape(\r\n  box: BoxGeometry,\r\n  radii: BorderRadii,\r\n  ctx: RenderContext,\r\n): SVGElement {\r\n  if (hasRadius(radii) && !isUniformRadius(radii)) {\r\n    const path = createSvgElement(ctx.svgDocument, \"path\");\r\n    path.setAttribute(\"d\", buildRoundedRectPath(box.x, box.y, box.width, box.height, radii));\r\n    return path;\r\n  }\r\n\r\n  const rect = createSvgElement(ctx.svgDocument, \"rect\");\r\n  setAttributes(rect, { x: box.x, y: box.y, width: box.width, height: box.height });\r\n\r\n  if (hasRadius(radii) && isUniformRadius(radii)) {\r\n    setAttributes(rect, { rx: radii.topLeft[0], ry: radii.topLeft[1] });\r\n  }\r\n\r\n  return rect;\r\n}\r\n\r\n/** Expand (or shrink if negative) radii by a given amount */\r\nfunction expandRadii(radii: BorderRadii, amount: number): BorderRadii {\r\n  return {\r\n    topLeft: [Math.max(0, radii.topLeft[0] + amount), Math.max(0, radii.topLeft[1] + amount)],\r\n    topRight: [Math.max(0, radii.topRight[0] + amount), Math.max(0, radii.topRight[1] + amount)],\r\n    bottomRight: [Math.max(0, radii.bottomRight[0] + amount), Math.max(0, radii.bottomRight[1] + amount)],\r\n    bottomLeft: [Math.max(0, radii.bottomLeft[0] + amount), Math.max(0, radii.bottomLeft[1] + amount)],\r\n  };\r\n}\r\n","import type { RenderContext, BoxGeometry } from \"../types.js\";\r\nimport { createSvgElement, setAttributes } from \"../utils/dom.js\";\r\nimport { buildRoundedRectPath } from \"../utils/geometry.js\";\r\n\r\nexport type ClipPathShape =\r\n  | { type: \"inset\"; top: number; right: number; bottom: number; left: number; round?: string }\r\n  | { type: \"circle\"; radius: number; cx: number; cy: number; cxPct?: boolean; cyPct?: boolean }\r\n  | { type: \"ellipse\"; rx: number; ry: number; cx: number; cy: number; cxPct?: boolean; cyPct?: boolean }\r\n  | { type: \"polygon\"; points: [number, number][] }\r\n  | { type: \"path\"; d: string };\r\n\r\n/** Parse a CSS length value, detecting percentage vs pixel units */\r\nfunction parseLengthValue(raw: string): { value: number; isPct: boolean } {\r\n  const trimmed = raw.trim();\r\n  if (trimmed.endsWith(\"%\")) {\r\n    return { value: parseFloat(trimmed) || 0, isPct: true };\r\n  }\r\n  return { value: parseFloat(trimmed) || 0, isPct: false };\r\n}\r\n\r\n/**\r\n * Parse a CSS clip-path value into a ClipPathShape.\r\n * Handles both pixel and percentage values (browser may keep center positions as %).\r\n */\r\nexport function parseClipPath(value: string): ClipPathShape | null {\r\n  if (!value || value === \"none\") return null;\r\n\r\n  const insetMatch = value.match(/^inset\\((.+)\\)$/);\r\n  if (insetMatch) return parseInset(insetMatch[1]!);\r\n\r\n  const circleMatch = value.match(/^circle\\((.+)\\)$/);\r\n  if (circleMatch) return parseCircle(circleMatch[1]!);\r\n\r\n  const ellipseMatch = value.match(/^ellipse\\((.+)\\)$/);\r\n  if (ellipseMatch) return parseEllipse(ellipseMatch[1]!);\r\n\r\n  const polygonMatch = value.match(/^polygon\\((.+)\\)$/);\r\n  if (polygonMatch) return parsePolygon(polygonMatch[1]!);\r\n\r\n  const pathMatch = value.match(/^path\\([\"']?(.+?)[\"']?\\)$/);\r\n  if (pathMatch) return { type: \"path\", d: pathMatch[1]! };\r\n\r\n  return null;\r\n}\r\n\r\nfunction parseInset(args: string): ClipPathShape | null {\r\n  // inset(top right bottom left round radii)\r\n  const roundIdx = args.indexOf(\" round \");\r\n  let insetPart = args;\r\n  let round: string | undefined;\r\n  if (roundIdx >= 0) {\r\n    insetPart = args.slice(0, roundIdx);\r\n    round = args.slice(roundIdx + 7).trim();\r\n  }\r\n\r\n  const values = insetPart.trim().split(/\\s+/).map((v) => parseFloat(v) || 0);\r\n  const top = values[0] ?? 0;\r\n  const right = values[1] ?? top;\r\n  const bottom = values[2] ?? top;\r\n  const left = values[3] ?? right;\r\n\r\n  return { type: \"inset\", top, right, bottom, left, round };\r\n}\r\n\r\nfunction parseCircle(args: string): ClipPathShape | null {\r\n  // circle(radius at cx cy)\r\n  const atIdx = args.indexOf(\" at \");\r\n  let radius = 0;\r\n  let cx = 0;\r\n  let cy = 0;\r\n  let cxPct = false;\r\n  let cyPct = false;\r\n\r\n  if (atIdx >= 0) {\r\n    radius = parseFloat(args.slice(0, atIdx)) || 0;\r\n    const center = args.slice(atIdx + 4).trim().split(/\\s+/);\r\n    const cxVal = parseLengthValue(center[0]!);\r\n    const cyVal = parseLengthValue(center[1]!);\r\n    cx = cxVal.value; cxPct = cxVal.isPct;\r\n    cy = cyVal.value; cyPct = cyVal.isPct;\r\n  } else {\r\n    radius = parseFloat(args) || 0;\r\n    // CSS spec: default center is 50% 50%\r\n    cx = 50; cy = 50;\r\n    cxPct = true; cyPct = true;\r\n  }\r\n\r\n  return { type: \"circle\", radius, cx, cy, cxPct, cyPct };\r\n}\r\n\r\nfunction parseEllipse(args: string): ClipPathShape | null {\r\n  // ellipse(rx ry at cx cy)\r\n  const atIdx = args.indexOf(\" at \");\r\n  let rx = 0;\r\n  let ry = 0;\r\n  let cx = 0;\r\n  let cy = 0;\r\n  let cxPct = false;\r\n  let cyPct = false;\r\n\r\n  if (atIdx >= 0) {\r\n    const radii = args.slice(0, atIdx).trim().split(/\\s+/);\r\n    rx = parseFloat(radii[0]!) || 0;\r\n    ry = parseFloat(radii[1]!) || 0;\r\n    const center = args.slice(atIdx + 4).trim().split(/\\s+/);\r\n    const cxVal = parseLengthValue(center[0]!);\r\n    const cyVal = parseLengthValue(center[1]!);\r\n    cx = cxVal.value; cxPct = cxVal.isPct;\r\n    cy = cyVal.value; cyPct = cyVal.isPct;\r\n  } else {\r\n    const parts = args.trim().split(/\\s+/);\r\n    rx = parseFloat(parts[0]!) || 0;\r\n    ry = parseFloat(parts[1]!) || 0;\r\n    // CSS spec: default center is 50% 50%\r\n    cx = 50; cy = 50;\r\n    cxPct = true; cyPct = true;\r\n  }\r\n\r\n  return { type: \"ellipse\", rx, ry, cx, cy, cxPct, cyPct };\r\n}\r\n\r\nfunction parsePolygon(args: string): ClipPathShape | null {\r\n  // polygon(x1 y1, x2 y2, ...)\r\n  // Remove optional fill-rule prefix\r\n  let cleaned = args.trim();\r\n  if (cleaned.startsWith(\"nonzero,\") || cleaned.startsWith(\"evenodd,\")) {\r\n    cleaned = cleaned.slice(cleaned.indexOf(\",\") + 1).trim();\r\n  }\r\n\r\n  const points: [number, number][] = [];\r\n  const pairs = cleaned.split(\",\");\r\n\r\n  for (const pair of pairs) {\r\n    const parts = pair.trim().split(/\\s+/);\r\n    if (parts.length >= 2) {\r\n      points.push([parseFloat(parts[0]!) || 0, parseFloat(parts[1]!) || 0]);\r\n    }\r\n  }\r\n\r\n  if (points.length < 3) return null;\r\n  return { type: \"polygon\", points };\r\n}\r\n\r\n/**\r\n * Create an SVG <clipPath> element in defs and return its ID.\r\n * The clip shape is positioned relative to the element's box.\r\n */\r\nexport function createSvgClipPath(\r\n  shape: ClipPathShape,\r\n  box: BoxGeometry,\r\n  ctx: RenderContext,\r\n): string | null {\r\n  const clipId = ctx.idGenerator.next(\"clip\");\r\n  const clipPath = createSvgElement(ctx.svgDocument, \"clipPath\");\r\n  clipPath.setAttribute(\"id\", clipId);\r\n\r\n  const svgShape = shapeToSvg(shape, box, ctx, ctx.compat.inlineClipPathTransforms);\r\n  if (!svgShape) return null;\r\n\r\n  clipPath.appendChild(svgShape);\r\n  ctx.defs.appendChild(clipPath);\r\n\r\n  return clipId;\r\n}\r\n\r\n/**\r\n * Translate all absolute coordinates in SVG path data by (dx, dy).\r\n * Handles M, L, C, S, Q, T, A commands and their lowercase (relative) forms.\r\n * Relative commands (lowercase) are left unchanged since they're already relative.\r\n */\r\nfunction translatePathData(d: string, dx: number, dy: number): string {\r\n  // Tokenize: split on command letters, keeping them\r\n  return d.replace(/([MLHVCSQTAZmlhvcsqtaz])([^MLHVCSQTAZmlhvcsqtaz]*)/g, (_, cmd: string, args: string) => {\r\n    const nums = args.match(/-?\\d*\\.?\\d+(?:e[+-]?\\d+)?/gi)?.map(Number) ?? [];\r\n    if (nums.length === 0) return cmd + args;\r\n\r\n    switch (cmd) {\r\n      case \"M\": case \"L\": case \"T\":\r\n        // Pairs of (x, y)\r\n        for (let i = 0; i < nums.length - 1; i += 2) {\r\n          nums[i] += dx;\r\n          nums[i + 1] += dy;\r\n        }\r\n        break;\r\n      case \"H\":\r\n        for (let i = 0; i < nums.length; i++) nums[i] += dx;\r\n        break;\r\n      case \"V\":\r\n        for (let i = 0; i < nums.length; i++) nums[i] += dy;\r\n        break;\r\n      case \"C\":\r\n        // 6 values: (x1,y1, x2,y2, x,y)\r\n        for (let i = 0; i < nums.length - 1; i += 2) {\r\n          nums[i] += dx;\r\n          nums[i + 1] += dy;\r\n        }\r\n        break;\r\n      case \"S\": case \"Q\":\r\n        // 4 values: (x1,y1, x,y) or (x2,y2, x,y)\r\n        for (let i = 0; i < nums.length - 1; i += 2) {\r\n          nums[i] += dx;\r\n          nums[i + 1] += dy;\r\n        }\r\n        break;\r\n      case \"A\":\r\n        // 7 values: (rx, ry, angle, largeArc, sweep, x, y) — only translate x,y\r\n        for (let i = 0; i < nums.length; i += 7) {\r\n          if (i + 5 < nums.length) nums[i + 5] += dx;\r\n          if (i + 6 < nums.length) nums[i + 6] += dy;\r\n        }\r\n        break;\r\n      // Relative commands (lowercase) — leave unchanged\r\n      default:\r\n        return cmd + args;\r\n    }\r\n    return cmd + nums.join(\" \");\r\n  });\r\n}\r\n\r\nfunction shapeToSvg(\r\n  shape: ClipPathShape,\r\n  box: BoxGeometry,\r\n  ctx: RenderContext,\r\n  inlineTransforms: boolean = false,\r\n): SVGElement | null {\r\n  switch (shape.type) {\r\n    case \"inset\": {\r\n      const x = box.x + shape.left;\r\n      const y = box.y + shape.top;\r\n      const w = Math.max(0, box.width - shape.left - shape.right);\r\n      const h = Math.max(0, box.height - shape.top - shape.bottom);\r\n\r\n      if (shape.round) {\r\n        // Parse border-radius shorthand for inset\r\n        const radiiValues = shape.round.split(\"/\").map((part) =>\r\n          part.trim().split(/\\s+/).map((v) => parseFloat(v) || 0),\r\n        );\r\n        const h_values = radiiValues[0] ?? [0];\r\n        const v_values = radiiValues[1] ?? h_values;\r\n\r\n        const radii = {\r\n          topLeft: [h_values[0] ?? 0, v_values[0] ?? 0] as [number, number],\r\n          topRight: [h_values[1] ?? h_values[0] ?? 0, v_values[1] ?? v_values[0] ?? 0] as [number, number],\r\n          bottomRight: [h_values[2] ?? h_values[0] ?? 0, v_values[2] ?? v_values[0] ?? 0] as [number, number],\r\n          bottomLeft: [h_values[3] ?? h_values[1] ?? h_values[0] ?? 0, v_values[3] ?? v_values[1] ?? v_values[0] ?? 0] as [number, number],\r\n        };\r\n\r\n        const path = createSvgElement(ctx.svgDocument, \"path\");\r\n        path.setAttribute(\"d\", buildRoundedRectPath(x, y, w, h, radii));\r\n        return path;\r\n      }\r\n\r\n      const rect = createSvgElement(ctx.svgDocument, \"rect\");\r\n      setAttributes(rect, { x, y, width: w, height: h });\r\n      return rect;\r\n    }\r\n\r\n    case \"circle\": {\r\n      const resolvedCx = shape.cxPct ? (shape.cx / 100) * box.width : shape.cx;\r\n      const resolvedCy = shape.cyPct ? (shape.cy / 100) * box.height : shape.cy;\r\n      const circle = createSvgElement(ctx.svgDocument, \"circle\");\r\n      setAttributes(circle, {\r\n        cx: box.x + resolvedCx,\r\n        cy: box.y + resolvedCy,\r\n        r: shape.radius,\r\n      });\r\n      return circle;\r\n    }\r\n\r\n    case \"ellipse\": {\r\n      const resolvedCx = shape.cxPct ? (shape.cx / 100) * box.width : shape.cx;\r\n      const resolvedCy = shape.cyPct ? (shape.cy / 100) * box.height : shape.cy;\r\n      const ellipse = createSvgElement(ctx.svgDocument, \"ellipse\");\r\n      setAttributes(ellipse, {\r\n        cx: box.x + resolvedCx,\r\n        cy: box.y + resolvedCy,\r\n        rx: shape.rx,\r\n        ry: shape.ry,\r\n      });\r\n      return ellipse;\r\n    }\r\n\r\n    case \"polygon\": {\r\n      const polygon = createSvgElement(ctx.svgDocument, \"polygon\");\r\n      const pointsStr = shape.points\r\n        .map(([x, y]) => `${box.x + x},${box.y + y}`)\r\n        .join(\" \");\r\n      polygon.setAttribute(\"points\", pointsStr);\r\n      return polygon;\r\n    }\r\n\r\n    case \"path\": {\r\n      const path = createSvgElement(ctx.svgDocument, \"path\");\r\n      if (inlineTransforms && (box.x !== 0 || box.y !== 0)) {\r\n        // Pre-translate path data to avoid transform attribute inside <clipPath>\r\n        // (Inkscape ignores transforms on elements inside <clipPath>)\r\n        path.setAttribute(\"d\", translatePathData(shape.d, box.x, box.y));\r\n      } else {\r\n        path.setAttribute(\"d\", shape.d);\r\n        path.setAttribute(\"transform\", `translate(${box.x}, ${box.y})`);\r\n      }\r\n      return path;\r\n    }\r\n\r\n    default:\r\n      return null;\r\n  }\r\n}\r\n","import type { RenderContext, BorderRadii, BoxGeometry } from \"../types.js\";\r\nimport {\r\n  createSvgElement,\r\n  setAttributes,\r\n  isImageElement,\r\n  isCanvasElement,\r\n  isFormElement,\r\n  getPseudoStyles,\r\n} from \"../utils/dom.js\";\r\nimport { getRelativeBox, buildRoundedRectPath } from \"../utils/geometry.js\";\r\nimport {\r\n  parseBorders,\r\n  parseBorderRadii,\r\n  clampRadii,\r\n  hasBorder,\r\n  hasRadius,\r\n  isUniformRadius,\r\n  hasOverflowClip,\r\n  parseBackgroundColor,\r\n  hasBackgroundImage,\r\n  isVisibilityHidden,\r\n} from \"../core/styles.js\";\r\nimport { parseLinearGradient, createSvgLinearGradient, rasterizeGradient } from \"../assets/gradients.js\";\r\nimport { imageToDataUrl, extractUrlFromCss, canvasToDataUrl } from \"../assets/images.js\";\r\nimport { cssTransformToSvg } from \"../transforms/svg.js\";\r\nimport { createSvgFilter } from \"../assets/filters.js\";\r\nimport { parseBoxShadows, renderBoxShadows } from \"../assets/box-shadow.js\";\r\nimport { parseClipPath, createSvgClipPath } from \"../assets/clip-path.js\";\r\n\r\n/**\r\n * Render an HTML element's visual properties (background, borders, overflow mask).\r\n * Returns a group containing the element's own visuals.\r\n * Children are rendered separately by the traversal engine.\r\n */\r\nexport async function renderHtmlElement(\r\n  element: Element,\r\n  rootElement: Element,\r\n  ctx: RenderContext,\r\n): Promise<SVGGElement> {\r\n  const group = createSvgElement(ctx.svgDocument, \"g\") as SVGGElement;\r\n  const styles = window.getComputedStyle(element);\r\n  let box = getRelativeBox(element, rootElement);\r\n\r\n  // When flattenTransforms is enabled, getBoundingClientRect returns the\r\n  // axis-aligned bounding box which loses rotated shapes (e.g. a CSS\r\n  // `transform: rotate(45deg)` diamond appears as a rectangle).\r\n  // Detect rotation and recover the pre-rotation dimensions so that\r\n  // visual shapes (background, borders) render at the correct size,\r\n  // then wrap them in a rotated SVG group.\r\n  let visualTransform: string | null = null;\r\n  if (ctx.options.flattenTransforms && styles.transform && styles.transform !== \"none\") {\r\n    const angle = extractRotationDeg(styles.transform);\r\n    if (Math.abs(angle) > 0.5) {\r\n      const el = element as HTMLElement;\r\n      const preW = el.offsetWidth;\r\n      const preH = el.offsetHeight;\r\n      if (preW > 0 && preH > 0 && (Math.abs(preW - box.width) > 1 || Math.abs(preH - box.height) > 1)) {\r\n        const cx = box.x + box.width / 2;\r\n        const cy = box.y + box.height / 2;\r\n        box = {\r\n          x: cx - preW / 2,\r\n          y: cy - preH / 2,\r\n          width: preW,\r\n          height: preH,\r\n        };\r\n        visualTransform = `rotate(${angle.toFixed(2)}, ${cx.toFixed(2)}, ${cy.toFixed(2)})`;\r\n      }\r\n    }\r\n  }\r\n\r\n  const radii = clampRadii(parseBorderRadii(styles), box.width, box.height);\r\n\r\n  // CSS Transforms (applied even when visibility:hidden for layout)\r\n  // When flattenTransforms is enabled, skip — getBoundingClientRect positions\r\n  // already include the effect of CSS transforms.\r\n  if (!ctx.options.flattenTransforms && styles.transform && styles.transform !== \"none\") {\r\n    const svgTransform = cssTransformToSvg(\r\n      styles.transform,\r\n      styles.transformOrigin,\r\n      box,\r\n    );\r\n    if (svgTransform) {\r\n      group.setAttribute(\"transform\", svgTransform);\r\n    }\r\n  }\r\n\r\n  // CSS clip-path (applied even when visibility:hidden, like transforms)\r\n  const clipPathValue = styles.clipPath;\r\n  if (clipPathValue && clipPathValue !== \"none\") {\r\n    const shape = parseClipPath(clipPathValue);\r\n    if (shape) {\r\n      const clipId = createSvgClipPath(shape, box, ctx);\r\n      if (clipId) group.setAttribute(\"clip-path\", `url(#${clipId})`);\r\n    }\r\n  }\r\n\r\n  // Skip own visuals when visibility:hidden, but keep the group\r\n  // so visible children can still be rendered inside it.\r\n  const hidden = isVisibilityHidden(styles);\r\n\r\n  if (!hidden) {\r\n    // CSS Filters (blur, brightness, contrast, drop-shadow, grayscale, etc.)\r\n    if (!ctx.compat.stripFilters && styles.filter && styles.filter !== \"none\") {\r\n      const filterId = createSvgFilter(styles.filter, ctx);\r\n      if (filterId) {\r\n        group.setAttribute(\"filter\", `url(#${filterId})`);\r\n      }\r\n    }\r\n\r\n    // Box shadows (rendered behind content)\r\n    if (!ctx.compat.stripBoxShadows) {\r\n      const boxShadowValue = styles.boxShadow;\r\n      if (boxShadowValue && boxShadowValue !== \"none\") {\r\n        const shadows = parseBoxShadows(boxShadowValue);\r\n        if (shadows.length > 0) {\r\n          renderBoxShadows(shadows, box, radii, ctx, group);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Background color\r\n    const bgColor = parseBackgroundColor(styles);\r\n    if (bgColor) {\r\n      const rect = createBoxShape(box, radii, ctx);\r\n      rect.setAttribute(\"fill\", bgColor);\r\n      group.appendChild(rect);\r\n    }\r\n\r\n    // Background image (gradients + URLs)\r\n    if (hasBackgroundImage(styles)) {\r\n      await renderBackgroundImages(styles, box, radii, ctx, group);\r\n    }\r\n\r\n    // Borders\r\n    const borders = parseBorders(styles);\r\n    if (hasBorder(borders)) {\r\n      renderBorders(group, box, borders, radii, ctx);\r\n    }\r\n\r\n    // Outline (rendered outside the border box)\r\n    renderOutline(styles, box, radii, ctx, group);\r\n\r\n    // <img> element\r\n    if (isImageElement(element) && element.src) {\r\n      const dataUrl = await imageToDataUrl(element.src);\r\n      const imgEl = createSvgElement(ctx.svgDocument, \"image\");\r\n      setAttributes(imgEl, {\r\n        x: box.x,\r\n        y: box.y,\r\n        width: box.width,\r\n        height: box.height,\r\n        href: dataUrl,\r\n      });\r\n      const objectFit = styles.objectFit || element.style.objectFit;\r\n      if (objectFit === \"fill\" || objectFit === \"\") {\r\n        imgEl.setAttribute(\"preserveAspectRatio\", \"none\");\r\n      } else if (objectFit === \"contain\" || objectFit === \"scale-down\") {\r\n        imgEl.setAttribute(\"preserveAspectRatio\", \"xMidYMid meet\");\r\n      } else if (objectFit === \"cover\") {\r\n        imgEl.setAttribute(\"preserveAspectRatio\", \"xMidYMid slice\");\r\n      }\r\n      // Clip image to border-radius when present\r\n      if (hasRadius(radii)) {\r\n        const clipId = ctx.idGenerator.next(\"clip\");\r\n        const clipPath = createSvgElement(ctx.svgDocument, \"clipPath\");\r\n        clipPath.setAttribute(\"id\", clipId);\r\n        const clipShape = createSvgElement(ctx.svgDocument, \"path\");\r\n        clipShape.setAttribute(\"d\", buildRoundedRectPath(box.x, box.y, box.width, box.height, radii));\r\n        clipPath.appendChild(clipShape);\r\n        ctx.defs.appendChild(clipPath);\r\n        imgEl.setAttribute(\"clip-path\", `url(#${clipId})`);\r\n      }\r\n      group.appendChild(imgEl);\r\n    }\r\n\r\n    // <canvas> element\r\n    if (isCanvasElement(element)) {\r\n      const dataUrl = canvasToDataUrl(element);\r\n      if (dataUrl) {\r\n        const imgEl = createSvgElement(ctx.svgDocument, \"image\");\r\n        setAttributes(imgEl, {\r\n          x: box.x,\r\n          y: box.y,\r\n          width: box.width,\r\n          height: box.height,\r\n          href: dataUrl,\r\n        });\r\n        group.appendChild(imgEl);\r\n      }\r\n    }\r\n\r\n    // Form element content (<input>, <select>, <textarea>)\r\n    if (isFormElement(element)) {\r\n      renderFormContent(element, styles, box, ctx, group);\r\n    }\r\n\r\n    // List markers (::marker for display:list-item)\r\n    if (styles.display === \"list-item\") {\r\n      renderListMarker(element, styles, box, ctx, group);\r\n    }\r\n\r\n    // CSS mask-image (used by icon systems like Wikipedia's Codex icons).\r\n    // Check both longhand (mask-image / -webkit-mask-image) and shorthand\r\n    // (mask / -webkit-mask) since some browsers don't decompose the shorthand.\r\n    if (!ctx.compat.stripMaskImage) {\r\n      const maskImage =\r\n        styles.webkitMaskImage ||\r\n        (styles as any).maskImage ||\r\n        (styles as any).webkitMask ||\r\n        (styles as any).mask;\r\n      if (maskImage && maskImage !== \"none\") {\r\n        await applyMaskImage(maskImage, styles, box, ctx, group);\r\n      }\r\n    }\r\n\r\n    // Pseudo-elements (::before, ::after)\r\n    await renderPseudoElement(element, \"::before\", rootElement, ctx, group);\r\n  }\r\n\r\n  // Wrap visual elements in a rotated subgroup for rotation recovery.\r\n  // Children (appended later via __childTarget) are unaffected since\r\n  // they use absolute coordinates from getBoundingClientRect.\r\n  if (visualTransform) {\r\n    const visualGroup = createSvgElement(ctx.svgDocument, \"g\") as SVGGElement;\r\n    visualGroup.setAttribute(\"transform\", visualTransform);\r\n    while (group.firstChild) {\r\n      visualGroup.appendChild(group.firstChild);\r\n    }\r\n    group.appendChild(visualGroup);\r\n  }\r\n\r\n  // Overflow clipping — wrap children in a mask or clipPath group.\r\n  // Skip for the root element: its border-radius clipping is handled at\r\n  // the SVG level in index.ts, and a mask here causes subpixel truncation.\r\n  if (hasOverflowClip(styles) && element !== rootElement) {\r\n    const clipGroup = ctx.compat.useClipPathForOverflow\r\n      ? createOverflowClipPath(box, radii, ctx)\r\n      : createOverflowMask(box, radii, ctx);\r\n    group.appendChild(clipGroup);\r\n    // The caller should append children to this clipGroup\r\n    (group as any).__childTarget = clipGroup;\r\n  }\r\n\r\n  return group;\r\n}\r\n\r\n/**\r\n * Render the ::after pseudo-element. Called after children are appended.\r\n */\r\nexport async function renderPseudoAfter(\r\n  element: Element,\r\n  rootElement: Element,\r\n  ctx: RenderContext,\r\n  group: SVGGElement,\r\n): Promise<void> {\r\n  await renderPseudoElement(element, \"::after\", rootElement, ctx, group);\r\n}\r\n\r\n/** Get the child target group (mask group if overflow:hidden, else the group itself) */\r\nexport function getChildTarget(group: SVGGElement): SVGElement {\r\n  return (group as any).__childTarget ?? group;\r\n}\r\n\r\n/**\r\n * Create an SVG shape for a box — <rect> for uniform/no radius,\r\n * <path> for non-uniform border-radius.\r\n */\r\nfunction createBoxShape(\r\n  box: BoxGeometry,\r\n  radii: BorderRadii,\r\n  ctx: RenderContext,\r\n): SVGElement {\r\n  if (hasRadius(radii) && !isUniformRadius(radii)) {\r\n    return createRoundedRectPath(box, radii, ctx);\r\n  }\r\n\r\n  const rect = createSvgElement(ctx.svgDocument, \"rect\");\r\n  setAttributes(rect, {\r\n    x: box.x,\r\n    y: box.y,\r\n    width: box.width,\r\n    height: box.height,\r\n  });\r\n\r\n  if (hasRadius(radii) && isUniformRadius(radii)) {\r\n    setAttributes(rect, {\r\n      rx: radii.topLeft[0],\r\n      ry: radii.topLeft[1],\r\n    });\r\n  }\r\n\r\n  return rect;\r\n}\r\n\r\n/** Create a <path> with non-uniform border-radius */\r\nfunction createRoundedRectPath(\r\n  box: BoxGeometry,\r\n  radii: BorderRadii,\r\n  ctx: RenderContext,\r\n): SVGPathElement {\r\n  const path = createSvgElement(ctx.svgDocument, \"path\");\r\n  path.setAttribute(\"d\", buildRoundedRectPath(box.x, box.y, box.width, box.height, radii));\r\n  return path;\r\n}\r\n\r\n/** Get SVG stroke-dasharray for a CSS border style */\r\nfunction borderDashArray(style: string, width: number): string | null {\r\n  if (style === \"dashed\") return `${width * 3} ${width * 2}`;\r\n  if (style === \"dotted\") return `${width} ${width}`;\r\n  return null;\r\n}\r\n\r\n/** Render borders as SVG rects (strokes) */\r\nfunction renderBorders(\r\n  group: SVGGElement,\r\n  box: BoxGeometry,\r\n  borders: ReturnType<typeof parseBorders>,\r\n  radii: BorderRadii,\r\n  ctx: RenderContext,\r\n): void {\r\n  // For uniform borders, use a single stroked rect\r\n  if (\r\n    borders.top.width === borders.right.width &&\r\n    borders.right.width === borders.bottom.width &&\r\n    borders.bottom.width === borders.left.width &&\r\n    borders.top.color === borders.right.color &&\r\n    borders.right.color === borders.bottom.color &&\r\n    borders.bottom.color === borders.left.color &&\r\n    borders.top.style === borders.right.style &&\r\n    borders.right.style === borders.bottom.style &&\r\n    borders.bottom.style === borders.left.style &&\r\n    borders.top.width > 0 &&\r\n    borders.top.style !== \"none\"\r\n  ) {\r\n    const halfW = borders.top.width / 2;\r\n    const insetBox: BoxGeometry = {\r\n      x: box.x + halfW,\r\n      y: box.y + halfW,\r\n      width: Math.max(0, box.width - borders.top.width),\r\n      height: Math.max(0, box.height - borders.top.width),\r\n    };\r\n\r\n    // Inset the radii by the border width\r\n    const insetRadii: BorderRadii = {\r\n      topLeft: [Math.max(0, radii.topLeft[0] - halfW), Math.max(0, radii.topLeft[1] - halfW)],\r\n      topRight: [Math.max(0, radii.topRight[0] - halfW), Math.max(0, radii.topRight[1] - halfW)],\r\n      bottomRight: [Math.max(0, radii.bottomRight[0] - halfW), Math.max(0, radii.bottomRight[1] - halfW)],\r\n      bottomLeft: [Math.max(0, radii.bottomLeft[0] - halfW), Math.max(0, radii.bottomLeft[1] - halfW)],\r\n    };\r\n\r\n    const shape = createBoxShape(insetBox, insetRadii, ctx);\r\n    setAttributes(shape, {\r\n      fill: \"none\",\r\n      stroke: borders.top.color,\r\n      \"stroke-width\": borders.top.width,\r\n    });\r\n    const dash = borderDashArray(borders.top.style, borders.top.width);\r\n    if (dash) shape.setAttribute(\"stroke-dasharray\", dash);\r\n\r\n    group.appendChild(shape);\r\n    return;\r\n  }\r\n\r\n  // Non-uniform borders: render each side individually.\r\n  // Solid borders use trapezoid fills with diagonal corner joins.\r\n  // Dashed/dotted borders use stroked center-lines with dasharray.\r\n  const { x, y, width, height } = box;\r\n  const bT = borders.top.width;\r\n  const bR = borders.right.width;\r\n  const bB = borders.bottom.width;\r\n  const bL = borders.left.width;\r\n\r\n  // Outer corners\r\n  const ox0 = x, oy0 = y;\r\n  const ox1 = x + width, oy1 = y + height;\r\n\r\n  // Inner corners (inset by border widths)\r\n  const ix0 = x + bL, iy0 = y + bT;\r\n  const ix1 = x + width - bR, iy1 = y + height - bB;\r\n\r\n  const sides: { w: number; side: ReturnType<typeof parseBorders>[keyof ReturnType<typeof parseBorders>]; trapD: string; lineD: string }[] = [\r\n    { w: bT, side: borders.top, trapD: `M ${ox0} ${oy0} L ${ox1} ${oy0} L ${ix1} ${iy0} L ${ix0} ${iy0} Z`, lineD: `M ${ix0} ${oy0 + bT / 2} L ${ix1} ${oy0 + bT / 2}` },\r\n    { w: bR, side: borders.right, trapD: `M ${ox1} ${oy0} L ${ox1} ${oy1} L ${ix1} ${iy1} L ${ix1} ${iy0} Z`, lineD: `M ${ox1 - bR / 2} ${iy0} L ${ox1 - bR / 2} ${iy1}` },\r\n    { w: bB, side: borders.bottom, trapD: `M ${ox1} ${oy1} L ${ox0} ${oy1} L ${ix0} ${iy1} L ${ix1} ${iy1} Z`, lineD: `M ${ix1} ${oy1 - bB / 2} L ${ix0} ${oy1 - bB / 2}` },\r\n    { w: bL, side: borders.left, trapD: `M ${ox0} ${oy1} L ${ox0} ${oy0} L ${ix0} ${iy0} L ${ix0} ${iy1} Z`, lineD: `M ${ox0 + bL / 2} ${iy1} L ${ox0 + bL / 2} ${iy0}` },\r\n  ];\r\n\r\n  for (const { w, side, trapD, lineD } of sides) {\r\n    if (w <= 0 || side.style === \"none\") continue;\r\n    const dash = borderDashArray(side.style, w);\r\n    if (dash) {\r\n      // Dashed/dotted: stroked center-line\r\n      const line = createSvgElement(ctx.svgDocument, \"path\");\r\n      setAttributes(line, { d: lineD, fill: \"none\", stroke: side.color, \"stroke-width\": w });\r\n      line.setAttribute(\"stroke-dasharray\", dash);\r\n      group.appendChild(line);\r\n    } else {\r\n      // Solid: trapezoid fill\r\n      const path = createSvgElement(ctx.svgDocument, \"path\");\r\n      path.setAttribute(\"d\", trapD);\r\n      path.setAttribute(\"fill\", side.color);\r\n      group.appendChild(path);\r\n    }\r\n  }\r\n}\r\n\r\n/** Create an overflow mask using <mask> for Figma compatibility */\r\nfunction createOverflowMask(\r\n  box: BoxGeometry,\r\n  radii: BorderRadii,\r\n  ctx: RenderContext,\r\n): SVGGElement {\r\n  const maskId = ctx.idGenerator.next(\"mask\");\r\n  const mask = createSvgElement(ctx.svgDocument, \"mask\");\r\n  mask.setAttribute(\"id\", maskId);\r\n\r\n  const maskRect = createBoxShape(box, radii, ctx);\r\n  maskRect.setAttribute(\"fill\", \"white\");\r\n  mask.appendChild(maskRect);\r\n  ctx.defs.appendChild(mask);\r\n\r\n  const masked = createSvgElement(ctx.svgDocument, \"g\") as SVGGElement;\r\n  masked.setAttribute(\"mask\", `url(#${maskId})`);\r\n\r\n  return masked;\r\n}\r\n\r\n/** Create an overflow clip using <clipPath> for Inkscape/LaTeX compatibility */\r\nfunction createOverflowClipPath(\r\n  box: BoxGeometry,\r\n  radii: BorderRadii,\r\n  ctx: RenderContext,\r\n): SVGGElement {\r\n  const clipId = ctx.idGenerator.next(\"clip\");\r\n  const clipPath = createSvgElement(ctx.svgDocument, \"clipPath\");\r\n  clipPath.setAttribute(\"id\", clipId);\r\n\r\n  const clipShape = createBoxShape(box, radii, ctx);\r\n  clipPath.appendChild(clipShape);\r\n  ctx.defs.appendChild(clipPath);\r\n\r\n  const clipped = createSvgElement(ctx.svgDocument, \"g\") as SVGGElement;\r\n  clipped.setAttribute(\"clip-path\", `url(#${clipId})`);\r\n\r\n  return clipped;\r\n}\r\n\r\n/** Apply a clip mask to a single element */\r\nfunction applyClipMask(\r\n  target: SVGElement,\r\n  box: BoxGeometry,\r\n  radii: BorderRadii,\r\n  ctx: RenderContext,\r\n  group: SVGGElement,\r\n): void {\r\n  const maskId = ctx.idGenerator.next(\"mask\");\r\n  const mask = createSvgElement(ctx.svgDocument, \"mask\");\r\n  mask.setAttribute(\"id\", maskId);\r\n\r\n  const maskRect = createBoxShape(box, radii, ctx);\r\n  maskRect.setAttribute(\"fill\", \"white\");\r\n  mask.appendChild(maskRect);\r\n  ctx.defs.appendChild(mask);\r\n\r\n  const wrapper = createSvgElement(ctx.svgDocument, \"g\");\r\n  wrapper.setAttribute(\"mask\", `url(#${maskId})`);\r\n  wrapper.appendChild(target);\r\n  group.appendChild(wrapper);\r\n}\r\n\r\n/**\r\n * Apply CSS mask-image as an SVG alpha mask.\r\n *\r\n * Many icon systems (e.g. Wikipedia Codex, Material Design) use mask-image\r\n * to shape a solid background-color into an icon. We convert this to an SVG\r\n * <mask> element with mask-type:alpha and embed the mask image inside it.\r\n */\r\nasync function applyMaskImage(\r\n  maskImage: string,\r\n  styles: CSSStyleDeclaration,\r\n  box: BoxGeometry,\r\n  ctx: RenderContext,\r\n  group: SVGGElement,\r\n): Promise<void> {\r\n  const url = extractUrlFromCss(maskImage);\r\n  if (!url) return;\r\n\r\n  // Convert external URLs to data URLs for self-contained SVG output\r\n  let imageUrl = url;\r\n  if (!url.startsWith(\"data:\")) {\r\n    try {\r\n      imageUrl = await imageToDataUrl(url);\r\n    } catch {\r\n      return; // Skip if fetch fails\r\n    }\r\n  }\r\n\r\n  // Parse mask sizing (default: mask-size covers the element)\r\n  const maskSize = styles.webkitMaskSize || (styles as any).maskSize || \"auto\";\r\n  let imgWidth = box.width;\r\n  let imgHeight = box.height;\r\n  if (maskSize !== \"auto\" && maskSize !== \"contain\" && maskSize !== \"cover\") {\r\n    const parts = maskSize.split(/\\s+/);\r\n    const w = parseFloat(parts[0]!);\r\n    const h = parseFloat(parts[1] || parts[0]!);\r\n    if (!isNaN(w)) imgWidth = w;\r\n    if (!isNaN(h)) imgHeight = h;\r\n  }\r\n\r\n  // Create the SVG mask with alpha mode\r\n  const maskId = ctx.idGenerator.next(\"mask\");\r\n  const mask = createSvgElement(ctx.svgDocument, \"mask\");\r\n  mask.setAttribute(\"id\", maskId);\r\n  if (!ctx.compat.avoidStyleAttributes) {\r\n    mask.setAttribute(\"style\", \"mask-type: alpha\");\r\n  }\r\n\r\n  const imgEl = createSvgElement(ctx.svgDocument, \"image\");\r\n  setAttributes(imgEl, {\r\n    x: box.x,\r\n    y: box.y,\r\n    width: imgWidth,\r\n    height: imgHeight,\r\n    href: imageUrl,\r\n  });\r\n  mask.appendChild(imgEl);\r\n  ctx.defs.appendChild(mask);\r\n\r\n  group.setAttribute(\"mask\", `url(#${maskId})`);\r\n}\r\n\r\n/** Render list item marker (bullet, number, custom ::marker content) */\r\nfunction renderListMarker(\r\n  element: Element,\r\n  styles: CSSStyleDeclaration,\r\n  box: BoxGeometry,\r\n  ctx: RenderContext,\r\n  group: SVGGElement,\r\n): void {\r\n  // Try to get ::marker content via getComputedStyle\r\n  let markerText = \"\";\r\n  try {\r\n    const markerStyles = window.getComputedStyle(element, \"::marker\");\r\n    const content = markerStyles.content;\r\n    if (content && content !== \"none\" && content !== \"normal\") {\r\n      markerText = content.replace(/^[\"']|[\"']$/g, \"\");\r\n    }\r\n  } catch {\r\n    // ::marker pseudo-element not supported in this browser\r\n  }\r\n\r\n  // Fallback: generate marker from listStyleType\r\n  if (!markerText) {\r\n    const listStyleType = styles.listStyleType;\r\n    if (listStyleType === \"none\") return;\r\n\r\n    if (listStyleType === \"disc\") {\r\n      markerText = \"\\u2022\"; // •\r\n    } else if (listStyleType === \"circle\") {\r\n      markerText = \"\\u25CB\"; // ○\r\n    } else if (listStyleType === \"square\") {\r\n      markerText = \"\\u25A0\"; // ■\r\n    } else if (listStyleType === \"decimal\" || listStyleType === \"\" || !listStyleType) {\r\n      // Count preceding siblings to determine number\r\n      let count = 1;\r\n      let sibling = element.previousElementSibling;\r\n      while (sibling) {\r\n        const sibStyles = window.getComputedStyle(sibling);\r\n        if (sibStyles.display === \"list-item\") count++;\r\n        sibling = sibling.previousElementSibling;\r\n      }\r\n      markerText = `${count}.`;\r\n    } else {\r\n      markerText = \"\\u2022\"; // default bullet\r\n    }\r\n  }\r\n\r\n  if (!markerText) return;\r\n\r\n  const fontSize = parseFloat(styles.fontSize) || 16;\r\n  const paddingLeft = parseFloat(styles.paddingLeft) || 0;\r\n  const paddingTop = parseFloat(styles.paddingTop) || 0;\r\n  const lineHeight = parseFloat(styles.lineHeight) || fontSize * 1.2;\r\n\r\n  // Marker sits to the left of the content box, vertically aligned with the first line\r\n  const markerX = box.x + paddingLeft - 6;\r\n  const markerY = box.y + paddingTop + (lineHeight - fontSize) / 2 + fontSize * 0.8;\r\n\r\n  const textEl = createSvgElement(ctx.svgDocument, \"text\");\r\n  setAttributes(textEl, {\r\n    x: markerX.toFixed(2),\r\n    y: markerY.toFixed(2),\r\n    \"font-family\": styles.fontFamily,\r\n    \"font-size\": styles.fontSize,\r\n    fill: styles.color,\r\n    \"text-anchor\": \"end\",\r\n  });\r\n  textEl.textContent = markerText;\r\n  group.appendChild(textEl);\r\n}\r\n\r\n/** Render form element text content (value, placeholder, selected option) */\r\nfunction renderFormContent(\r\n  element: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement,\r\n  styles: CSSStyleDeclaration,\r\n  box: BoxGeometry,\r\n  ctx: RenderContext,\r\n  group: SVGGElement,\r\n): void {\r\n  let text = \"\";\r\n  let isPlaceholder = false;\r\n\r\n  if (element instanceof HTMLSelectElement) {\r\n    const selected = element.selectedOptions[0];\r\n    text = selected?.text ?? \"\";\r\n  } else {\r\n    text = element.value;\r\n    if (!text && element.placeholder) {\r\n      text = element.placeholder;\r\n      isPlaceholder = true;\r\n    }\r\n  }\r\n\r\n  if (!text) return;\r\n\r\n  const fontSize = parseFloat(styles.fontSize) || 16;\r\n  const paddingLeft = parseFloat(styles.paddingLeft) || 0;\r\n  const paddingTop = parseFloat(styles.paddingTop) || 0;\r\n  const borderTop = parseFloat(styles.borderTopWidth) || 0;\r\n  const lineHeight = parseFloat(styles.lineHeight) || fontSize * 1.2;\r\n\r\n  const fillColor = isPlaceholder ? \"gray\" : styles.color;\r\n  const textX = box.x + paddingLeft;\r\n\r\n  // Textarea: render each line separately\r\n  if (element instanceof HTMLTextAreaElement) {\r\n    const lines = text.split(\"\\n\");\r\n    for (let i = 0; i < lines.length; i++) {\r\n      const lineText = lines[i]!;\r\n      if (!lineText) continue;\r\n\r\n      const topPadding = (lineHeight - fontSize) / 2;\r\n      const y = box.y + borderTop + paddingTop + i * lineHeight + topPadding + fontSize * 0.8;\r\n\r\n      const textEl = createSvgElement(ctx.svgDocument, \"text\");\r\n      setAttributes(textEl, {\r\n        x: textX.toFixed(2),\r\n        y: y.toFixed(2),\r\n        \"font-family\": styles.fontFamily,\r\n        \"font-size\": styles.fontSize,\r\n        \"font-weight\": styles.fontWeight,\r\n        \"font-style\": styles.fontStyle,\r\n        fill: fillColor,\r\n      });\r\n      if (isPlaceholder) textEl.setAttribute(\"opacity\", \"0.54\");\r\n      textEl.textContent = lineText;\r\n      group.appendChild(textEl);\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Single-line inputs and selects: vertically centered\r\n  const borderBottom = parseFloat(styles.borderBottomWidth) || 0;\r\n  const innerHeight = box.height - borderTop - borderBottom;\r\n  const baselineY = box.y + borderTop + innerHeight / 2 + fontSize * 0.35;\r\n\r\n  const textEl = createSvgElement(ctx.svgDocument, \"text\");\r\n  setAttributes(textEl, {\r\n    x: textX.toFixed(2),\r\n    y: baselineY.toFixed(2),\r\n    \"font-family\": styles.fontFamily,\r\n    \"font-size\": styles.fontSize,\r\n    \"font-weight\": styles.fontWeight,\r\n    \"font-style\": styles.fontStyle,\r\n    fill: fillColor,\r\n  });\r\n\r\n  if (isPlaceholder) {\r\n    textEl.setAttribute(\"opacity\", \"0.54\");\r\n  }\r\n\r\n  textEl.textContent = text;\r\n  group.appendChild(textEl);\r\n}\r\n\r\n/** Render CSS outline as a stroked shape outside the border box */\r\nfunction renderOutline(\r\n  styles: CSSStyleDeclaration,\r\n  box: BoxGeometry,\r\n  radii: BorderRadii,\r\n  ctx: RenderContext,\r\n  group: SVGGElement,\r\n): void {\r\n  const outlineStyle = styles.outlineStyle;\r\n  if (!outlineStyle || outlineStyle === \"none\") return;\r\n\r\n  const outlineWidth = parseFloat(styles.outlineWidth) || 0;\r\n  if (outlineWidth <= 0) return;\r\n\r\n  const outlineColor = styles.outlineColor || styles.color;\r\n  const outlineOffset = parseFloat(styles.outlineOffset) || 0;\r\n\r\n  // The outline sits outlineOffset + outlineWidth/2 from the border edge\r\n  const expand = outlineOffset + outlineWidth / 2;\r\n  const outlineBox: BoxGeometry = {\r\n    x: box.x - expand,\r\n    y: box.y - expand,\r\n    width: box.width + expand * 2,\r\n    height: box.height + expand * 2,\r\n  };\r\n\r\n  // Expand radii by the offset\r\n  const outlineRadii: BorderRadii = {\r\n    topLeft: [Math.max(0, radii.topLeft[0] + expand), Math.max(0, radii.topLeft[1] + expand)],\r\n    topRight: [Math.max(0, radii.topRight[0] + expand), Math.max(0, radii.topRight[1] + expand)],\r\n    bottomRight: [Math.max(0, radii.bottomRight[0] + expand), Math.max(0, radii.bottomRight[1] + expand)],\r\n    bottomLeft: [Math.max(0, radii.bottomLeft[0] + expand), Math.max(0, radii.bottomLeft[1] + expand)],\r\n  };\r\n\r\n  const shape = createBoxShape(outlineBox, outlineRadii, ctx);\r\n  setAttributes(shape, {\r\n    fill: \"none\",\r\n    stroke: outlineColor,\r\n    \"stroke-width\": outlineWidth,\r\n  });\r\n\r\n  const dash = borderDashArray(outlineStyle, outlineWidth);\r\n  if (dash) shape.setAttribute(\"stroke-dasharray\", dash);\r\n\r\n  group.appendChild(shape);\r\n}\r\n\r\n/** Split a CSS value list on commas respecting parentheses */\r\nfunction splitCssValueList(str: string): string[] {\r\n  const parts: string[] = [];\r\n  let depth = 0;\r\n  let current = \"\";\r\n  for (const char of str) {\r\n    if (char === \"(\") depth++;\r\n    else if (char === \")\") depth--;\r\n    if (char === \",\" && depth === 0) {\r\n      parts.push(current.trim());\r\n      current = \"\";\r\n    } else {\r\n      current += char;\r\n    }\r\n  }\r\n  if (current.trim()) parts.push(current.trim());\r\n  return parts;\r\n}\r\n\r\ninterface BackgroundPlacement {\r\n  x: number;\r\n  y: number;\r\n  width: number;\r\n  height: number;\r\n  preserveAspectRatio: string;\r\n}\r\n\r\n/** Compute background image placement from background-size and background-position */\r\nfunction computeBackgroundPlacement(\r\n  bgSize: string,\r\n  bgPosition: string,\r\n  box: BoxGeometry,\r\n): BackgroundPlacement {\r\n  let width = box.width;\r\n  let height = box.height;\r\n  let par = \"none\";\r\n\r\n  // background-size\r\n  if (bgSize === \"contain\") {\r\n    par = \"xMidYMid meet\";\r\n  } else if (bgSize === \"cover\") {\r\n    par = \"xMidYMid slice\";\r\n  } else if (bgSize && bgSize !== \"auto\") {\r\n    const sizeParts = bgSize.split(/\\s+/);\r\n    const w = parseBgDimension(sizeParts[0]!, box.width);\r\n    const h = parseBgDimension(sizeParts[1] ?? \"auto\", box.height);\r\n    if (w !== null) width = w;\r\n    if (h !== null) height = h;\r\n  }\r\n\r\n  // background-position\r\n  let x = box.x;\r\n  let y = box.y;\r\n  if (bgPosition && bgPosition !== \"0% 0%\") {\r\n    const posParts = bgPosition.split(/\\s+/);\r\n    x = box.x + parseBgOffset(posParts[0] ?? \"0px\", box.width, width);\r\n    y = box.y + parseBgOffset(posParts[1] ?? \"0px\", box.height, height);\r\n  }\r\n\r\n  return { x, y, width, height, preserveAspectRatio: par };\r\n}\r\n\r\nfunction parseBgDimension(value: string, containerSize: number): number | null {\r\n  if (value === \"auto\") return null;\r\n  if (value.endsWith(\"%\")) return (parseFloat(value) / 100) * containerSize;\r\n  return parseFloat(value) || null;\r\n}\r\n\r\nfunction parseBgOffset(value: string, containerSize: number, imageSize: number): number {\r\n  if (value.endsWith(\"%\")) {\r\n    const pct = parseFloat(value) / 100;\r\n    return pct * (containerSize - imageSize);\r\n  }\r\n  return parseFloat(value) || 0;\r\n}\r\n\r\n/** Render background image layers */\r\nasync function renderBackgroundImages(\r\n  styles: CSSStyleDeclaration,\r\n  box: BoxGeometry,\r\n  radii: BorderRadii,\r\n  ctx: RenderContext,\r\n  group: SVGGElement,\r\n): Promise<void> {\r\n  const bgImages = splitCssValueList(styles.backgroundImage);\r\n  const bgSizes = splitCssValueList(styles.backgroundSize);\r\n  const bgPositions = splitCssValueList(styles.backgroundPosition);\r\n\r\n  // CSS layers: first = topmost, SVG: last appended = topmost\r\n  // Iterate in reverse so CSS-topmost layer is appended last (= SVG topmost)\r\n  for (let i = bgImages.length - 1; i >= 0; i--) {\r\n    const bgImage = bgImages[i]!;\r\n    if (bgImage === \"none\") continue;\r\n\r\n    const bgSize = bgSizes[i] ?? bgSizes[bgSizes.length - 1] ?? \"auto\";\r\n    const bgPosition = bgPositions[i] ?? bgPositions[bgPositions.length - 1] ?? \"0% 0%\";\r\n    const placement = computeBackgroundPlacement(bgSize, bgPosition, box);\r\n\r\n    await renderSingleBackgroundLayer(bgImage, placement, box, radii, ctx, group);\r\n  }\r\n}\r\n\r\n/** Render a single background image layer */\r\nasync function renderSingleBackgroundLayer(\r\n  bgImage: string,\r\n  placement: BackgroundPlacement,\r\n  box: BoxGeometry,\r\n  radii: BorderRadii,\r\n  ctx: RenderContext,\r\n  group: SVGGElement,\r\n): Promise<void> {\r\n  const gradient = parseLinearGradient(bgImage);\r\n  if (gradient) {\r\n    const gradientEl = createSvgLinearGradient(gradient, box, ctx);\r\n    const rect = createBoxShape(box, radii, ctx);\r\n    rect.setAttribute(\"fill\", `url(#${gradientEl.getAttribute(\"id\")})`);\r\n    group.appendChild(rect);\r\n    return;\r\n  }\r\n\r\n  // Conic / radial gradient — rasterize via Canvas 2D API\r\n  const rasterized = rasterizeGradient(bgImage, placement.width, placement.height);\r\n  if (rasterized) {\r\n    const imgEl = createSvgElement(ctx.svgDocument, \"image\");\r\n    setAttributes(imgEl, {\r\n      x: placement.x,\r\n      y: placement.y,\r\n      width: placement.width,\r\n      height: placement.height,\r\n      href: rasterized,\r\n      preserveAspectRatio: placement.preserveAspectRatio,\r\n    });\r\n    if (hasRadius(radii)) {\r\n      applyClipMask(imgEl, box, radii, ctx, group);\r\n    } else {\r\n      group.appendChild(imgEl);\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Background image URL\r\n  const url = extractUrlFromCss(bgImage);\r\n  if (url) {\r\n    const dataUrl = await imageToDataUrl(url);\r\n    const imgEl = createSvgElement(ctx.svgDocument, \"image\");\r\n    setAttributes(imgEl, {\r\n      x: placement.x,\r\n      y: placement.y,\r\n      width: placement.width,\r\n      height: placement.height,\r\n      href: dataUrl,\r\n      preserveAspectRatio: placement.preserveAspectRatio,\r\n    });\r\n    if (hasRadius(radii)) {\r\n      applyClipMask(imgEl, box, radii, ctx, group);\r\n    } else {\r\n      group.appendChild(imgEl);\r\n    }\r\n  }\r\n}\r\n\r\n/** Check if a pseudo-element has visual properties (background, clip-path) */\r\nfunction hasVisualProperties(styles: CSSStyleDeclaration): boolean {\r\n  if (parseBackgroundColor(styles)) return true;\r\n  if (hasBackgroundImage(styles)) return true;\r\n  const clipPath = styles.clipPath || (styles as any).webkitClipPath;\r\n  if (clipPath && clipPath !== \"none\") return true;\r\n  return false;\r\n}\r\n\r\n/**\r\n * Measure a pseudo-element's box by inserting a temporary DOM element\r\n * styled with the same positioning properties.\r\n */\r\nfunction measurePseudoBox(\r\n  element: Element,\r\n  pseudo: \"::before\" | \"::after\",\r\n  styles: CSSStyleDeclaration,\r\n  rootElement: Element,\r\n): { x: number; y: number; width: number; height: number } | null {\r\n  const marker = document.createElement(\"span\");\r\n  marker.style.cssText = `\r\n    position: ${styles.position};\r\n    display: ${styles.display === \"none\" ? \"none\" : styles.display};\r\n    top: ${styles.top}; right: ${styles.right};\r\n    bottom: ${styles.bottom}; left: ${styles.left};\r\n    width: ${styles.width}; height: ${styles.height};\r\n    margin: ${styles.margin}; padding: ${styles.padding};\r\n    box-sizing: ${styles.boxSizing};\r\n    visibility: hidden;\r\n    pointer-events: none;\r\n  `;\r\n\r\n  if (pseudo === \"::before\") {\r\n    element.insertBefore(marker, element.firstChild);\r\n  } else {\r\n    element.appendChild(marker);\r\n  }\r\n\r\n  const rect = marker.getBoundingClientRect();\r\n  element.removeChild(marker);\r\n\r\n  if (rect.width === 0 && rect.height === 0) return null;\r\n\r\n  const rootRect = rootElement.getBoundingClientRect();\r\n  return {\r\n    x: rect.left - rootRect.left,\r\n    y: rect.top - rootRect.top,\r\n    width: rect.width,\r\n    height: rect.height,\r\n  };\r\n}\r\n\r\n/** Render a pseudo-element (::before or ::after) */\r\nasync function renderPseudoElement(\r\n  element: Element,\r\n  pseudo: \"::before\" | \"::after\",\r\n  rootElement: Element,\r\n  ctx: RenderContext,\r\n  group: SVGGElement,\r\n): Promise<void> {\r\n  const styles = getPseudoStyles(element, pseudo);\r\n  const content = styles.content;\r\n\r\n  // content:none or content:normal means the pseudo-element is not generated\r\n  if (!content || content === \"none\" || content === \"normal\") {\r\n    return;\r\n  }\r\n\r\n  // Extract text content (strip quotes)\r\n  const text = content.replace(/^[\"']|[\"']$/g, \"\");\r\n  const hasVisuals = hasVisualProperties(styles);\r\n\r\n  // Skip if no text AND no visual properties\r\n  if (!text && !hasVisuals) return;\r\n\r\n  // Render visual properties (background + clip-path) for visual-only pseudo-elements.\r\n  // Many UI frameworks use ::before/::after with content:'' plus background and\r\n  // clip-path to render decorative shapes (e.g. custom handle icons, arrows).\r\n  if (hasVisuals) {\r\n    const pseudoBox = measurePseudoBox(element, pseudo, styles, rootElement);\r\n    if (pseudoBox) {\r\n      const bgColor = parseBackgroundColor(styles);\r\n      if (bgColor) {\r\n        const rect = createSvgElement(ctx.svgDocument, \"rect\");\r\n        setAttributes(rect, {\r\n          x: pseudoBox.x,\r\n          y: pseudoBox.y,\r\n          width: pseudoBox.width,\r\n          height: pseudoBox.height,\r\n          fill: bgColor,\r\n        });\r\n\r\n        // Apply clip-path if present\r\n        const clipPathValue = styles.clipPath || (styles as any).webkitClipPath;\r\n        if (clipPathValue && clipPathValue !== \"none\") {\r\n          const shape = parseClipPath(clipPathValue);\r\n          if (shape) {\r\n            const clipId = createSvgClipPath(shape, pseudoBox, ctx);\r\n            if (clipId) rect.setAttribute(\"clip-path\", `url(#${clipId})`);\r\n          }\r\n        }\r\n\r\n        group.appendChild(rect);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Render text content\r\n  if (!text) return;\r\n\r\n  const rootRect = rootElement.getBoundingClientRect();\r\n  const fontSize = parseFloat(styles.fontSize) || 16;\r\n\r\n  // Measure the pseudo-element's actual position by inserting a temporary span\r\n  // that replaces the pseudo-element's role in the layout\r\n  const marker = document.createElement(\"span\");\r\n  marker.style.cssText = `\r\n    font-family: ${styles.fontFamily};\r\n    font-size: ${styles.fontSize};\r\n    font-weight: ${styles.fontWeight};\r\n    font-style: ${styles.fontStyle};\r\n    letter-spacing: ${styles.letterSpacing};\r\n    visibility: hidden;\r\n    pointer-events: none;\r\n  `;\r\n  marker.textContent = text;\r\n\r\n  // Insert at the correct position (first child for ::before, last for ::after)\r\n  if (pseudo === \"::before\") {\r\n    element.insertBefore(marker, element.firstChild);\r\n  } else {\r\n    element.appendChild(marker);\r\n  }\r\n\r\n  const markerRect = marker.getBoundingClientRect();\r\n  const markerX = markerRect.left - rootRect.left;\r\n  const markerWidth = markerRect.width;\r\n  const markerHeight = markerRect.height;\r\n\r\n  // Compute baseline using same algorithm as text-node renderer\r\n  const topPadding = (markerHeight - fontSize) / 2;\r\n  const baselineY = markerRect.top - rootRect.top + topPadding + fontSize * 0.8;\r\n\r\n  element.removeChild(marker);\r\n\r\n  // Background for text pseudo-element (only if not already rendered above)\r\n  if (!hasVisuals) {\r\n    const bgColor = parseBackgroundColor(styles);\r\n    if (bgColor) {\r\n      const bgRect = createSvgElement(ctx.svgDocument, \"rect\");\r\n      setAttributes(bgRect, {\r\n        x: markerX,\r\n        y: markerRect.top - rootRect.top,\r\n        width: markerWidth,\r\n        height: markerHeight,\r\n        fill: bgColor,\r\n      });\r\n      group.appendChild(bgRect);\r\n    }\r\n  }\r\n\r\n  // Create a text element for the pseudo content\r\n  const textEl = createSvgElement(ctx.svgDocument, \"text\");\r\n  setAttributes(textEl, {\r\n    \"font-family\": styles.fontFamily,\r\n    \"font-size\": styles.fontSize,\r\n    \"font-weight\": styles.fontWeight,\r\n    \"font-style\": styles.fontStyle,\r\n    fill: styles.color,\r\n    x: markerX.toFixed(2),\r\n    y: baselineY.toFixed(2),\r\n  });\r\n\r\n  if (styles.letterSpacing && styles.letterSpacing !== \"normal\") {\r\n    textEl.setAttribute(\"letter-spacing\", styles.letterSpacing);\r\n  }\r\n\r\n  textEl.textContent = text;\r\n  group.appendChild(textEl);\r\n}\r\n\r\n/** Extract rotation angle in degrees from a CSS computed transform matrix */\r\nfunction extractRotationDeg(transform: string): number {\r\n  const match = transform.match(/^matrix\\(([^,]+),\\s*([^,]+)/);\r\n  if (!match) return 0;\r\n  const a = parseFloat(match[1]!);\r\n  const b = parseFloat(match[2]!);\r\n  if (isNaN(a) || isNaN(b)) return 0;\r\n  return Math.atan2(b, a) * (180 / Math.PI);\r\n}\r\n","import type { RenderContext } from \"../types.js\";\r\nimport { SVG_NS, XLINK_NS } from \"../utils/dom.js\";\r\n\r\n/**\r\n * Clone an inline SVG element into the output document,\r\n * rewriting IDs to avoid conflicts between multiple cloned SVGs\r\n * and resolving `currentColor` to the actual computed color.\r\n */\r\nexport function renderSvgElement(\r\n  element: SVGElement,\r\n  ctx: RenderContext,\r\n): SVGElement {\r\n  // Resolve currentColor from the SVG element's inherited CSS color\r\n  const computedColor = window.getComputedStyle(element).color || \"rgb(0, 0, 0)\";\r\n  const clone = cloneWithNamespace(element, ctx);\r\n  resolveCurrentColor(clone, computedColor);\r\n  rewriteIds(clone, ctx);\r\n  return clone;\r\n}\r\n\r\n/** Deep clone an SVG element into the target document, preserving namespaces */\r\nfunction cloneWithNamespace(\r\n  node: SVGElement,\r\n  ctx: RenderContext,\r\n  resolveDepth: number = 0,\r\n): SVGElement {\r\n  // Resolve <use> elements by inlining the referenced content\r\n  if (node.localName === \"use\" && resolveDepth < 5) {\r\n    const resolved = resolveUseElement(node, ctx, resolveDepth);\r\n    if (resolved) return resolved;\r\n    // Fallback: clone as-is if resolution fails\r\n  }\r\n\r\n  const clone = ctx.svgDocument.createElementNS(\r\n    node.namespaceURI || SVG_NS,\r\n    node.localName,\r\n  ) as SVGElement;\r\n\r\n  // Copy attributes\r\n  for (const attr of Array.from(node.attributes)) {\r\n    if (attr.namespaceURI === XLINK_NS) {\r\n      clone.setAttributeNS(XLINK_NS, attr.localName, attr.value);\r\n    } else if (attr.namespaceURI) {\r\n      clone.setAttributeNS(attr.namespaceURI, attr.localName, attr.value);\r\n    } else {\r\n      clone.setAttribute(attr.localName, attr.value);\r\n    }\r\n  }\r\n\r\n  // Inline CSS-applied fill/stroke that aren't present as attributes.\r\n  // Many icon systems (e.g. GitHub Octicons) set fill via CSS rules like\r\n  // `.octicon { fill: currentColor }` — these won't be in the attributes.\r\n  inlineSvgPresentationStyles(node, clone);\r\n\r\n  // Recurse into children\r\n  for (const child of Array.from(node.childNodes)) {\r\n    if (child.nodeType === Node.ELEMENT_NODE) {\r\n      clone.appendChild(cloneWithNamespace(child as SVGElement, ctx, resolveDepth));\r\n    } else if (child.nodeType === Node.TEXT_NODE) {\r\n      clone.appendChild(ctx.svgDocument.createTextNode(child.textContent || \"\"));\r\n    }\r\n  }\r\n\r\n  return clone;\r\n}\r\n\r\n/**\r\n * Resolve a <use> element by finding the referenced <symbol>/<g>/element\r\n * and inlining its content. Returns null if the reference can't be resolved.\r\n *\r\n * SVG <use> elements reference definitions via href=\"#id\", often pointing to\r\n * <symbol> elements in hidden sprite sheets elsewhere in the DOM. Since those\r\n * symbols won't exist in our output SVG, we inline the content directly.\r\n */\r\nfunction resolveUseElement(\r\n  useEl: SVGElement,\r\n  ctx: RenderContext,\r\n  resolveDepth: number,\r\n): SVGElement | null {\r\n  const href =\r\n    useEl.getAttribute(\"href\") ||\r\n    useEl.getAttributeNS(XLINK_NS, \"href\");\r\n\r\n  if (!href || !href.startsWith(\"#\")) return null;\r\n\r\n  const refId = href.slice(1);\r\n  const refEl = document.getElementById(refId);\r\n  if (!refEl) return null;\r\n\r\n  const group = ctx.svgDocument.createElementNS(SVG_NS, \"g\") as SVGElement;\r\n\r\n  // Copy presentation attributes from <use> (except href and geometry)\r\n  const skipAttrs = new Set([\"href\", \"xlink:href\", \"x\", \"y\", \"width\", \"height\"]);\r\n  for (const attr of Array.from(useEl.attributes)) {\r\n    if (skipAttrs.has(attr.localName)) continue;\r\n    if (attr.namespaceURI === XLINK_NS) continue;\r\n    if (attr.namespaceURI) {\r\n      group.setAttributeNS(attr.namespaceURI, attr.localName, attr.value);\r\n    } else {\r\n      group.setAttribute(attr.localName, attr.value);\r\n    }\r\n  }\r\n\r\n  // Apply x/y translation from <use>\r\n  const x = parseFloat(useEl.getAttribute(\"x\") || \"0\") || 0;\r\n  const y = parseFloat(useEl.getAttribute(\"y\") || \"0\") || 0;\r\n  if (x !== 0 || y !== 0) {\r\n    const existing = group.getAttribute(\"transform\") || \"\";\r\n    group.setAttribute(\"transform\", `translate(${x},${y}) ${existing}`.trim());\r\n  }\r\n\r\n  // Inline CSS-applied fill/stroke from the <use> element\r\n  inlineSvgPresentationStyles(useEl, group);\r\n\r\n  if (refEl.localName === \"symbol\") {\r\n    // <symbol> has a viewBox — wrap content in an <svg> to apply it\r\n    const viewBox = refEl.getAttribute(\"viewBox\");\r\n    const width = useEl.getAttribute(\"width\") || refEl.getAttribute(\"width\");\r\n    const height = useEl.getAttribute(\"height\") || refEl.getAttribute(\"height\");\r\n\r\n    const wrapper = ctx.svgDocument.createElementNS(SVG_NS, \"svg\") as SVGElement;\r\n    if (viewBox) wrapper.setAttribute(\"viewBox\", viewBox);\r\n    if (width) wrapper.setAttribute(\"width\", width);\r\n    if (height) wrapper.setAttribute(\"height\", height);\r\n    wrapper.setAttribute(\"overflow\", \"hidden\");\r\n\r\n    for (const child of Array.from(refEl.childNodes)) {\r\n      if (child.nodeType === Node.ELEMENT_NODE) {\r\n        wrapper.appendChild(cloneWithNamespace(child as SVGElement, ctx, resolveDepth + 1));\r\n      }\r\n    }\r\n    group.appendChild(wrapper);\r\n  } else {\r\n    // For other elements (<g>, <path>, etc.), clone the element itself\r\n    group.appendChild(cloneWithNamespace(refEl as SVGElement, ctx, resolveDepth + 1));\r\n  }\r\n\r\n  return group;\r\n}\r\n\r\n/** Inline key SVG presentation properties that may come from CSS rather than attributes */\r\nfunction inlineSvgPresentationStyles(source: SVGElement, clone: SVGElement): void {\r\n  const styles = window.getComputedStyle(source);\r\n\r\n  // fill — default in SVG is \"rgb(0, 0, 0)\" (black)\r\n  if (!clone.hasAttribute(\"fill\")) {\r\n    const fill = styles.fill;\r\n    if (fill && fill !== \"rgb(0, 0, 0)\") {\r\n      clone.setAttribute(\"fill\", fill);\r\n    }\r\n  }\r\n\r\n  // stroke — default is \"none\"\r\n  if (!clone.hasAttribute(\"stroke\")) {\r\n    const stroke = styles.stroke;\r\n    if (stroke && stroke !== \"none\") {\r\n      clone.setAttribute(\"stroke\", stroke);\r\n    }\r\n  }\r\n\r\n  // opacity\r\n  if (!clone.hasAttribute(\"opacity\")) {\r\n    const opacity = styles.opacity;\r\n    if (opacity && opacity !== \"1\") {\r\n      clone.setAttribute(\"opacity\", opacity);\r\n    }\r\n  }\r\n}\r\n\r\n/** Rewrite all id attributes and url(#id) references in the cloned tree */\r\nfunction rewriteIds(root: SVGElement, ctx: RenderContext): void {\r\n  const idMap = new Map<string, string>();\r\n\r\n  // First pass: collect and rewrite IDs\r\n  const allElements = root.querySelectorAll(\"[id]\");\r\n  for (const el of Array.from(allElements)) {\r\n    const oldId = el.getAttribute(\"id\")!;\r\n    const newId = ctx.idGenerator.next(\"svg\");\r\n    idMap.set(oldId, newId);\r\n    el.setAttribute(\"id\", newId);\r\n  }\r\n\r\n  // Also handle root element's id\r\n  if (root.hasAttribute(\"id\")) {\r\n    const oldId = root.getAttribute(\"id\")!;\r\n    if (!idMap.has(oldId)) {\r\n      const newId = ctx.idGenerator.next(\"svg\");\r\n      idMap.set(oldId, newId);\r\n      root.setAttribute(\"id\", newId);\r\n    }\r\n  }\r\n\r\n  if (idMap.size === 0) return;\r\n\r\n  // Second pass: rewrite url(#id) references in all attributes\r\n  rewriteUrlReferences(root, idMap);\r\n}\r\n\r\nfunction rewriteUrlReferences(\r\n  element: SVGElement,\r\n  idMap: Map<string, string>,\r\n): void {\r\n  for (const attr of Array.from(element.attributes)) {\r\n    if (attr.value.includes(\"url(#\")) {\r\n      let newValue = attr.value;\r\n      for (const [oldId, newId] of idMap) {\r\n        newValue = newValue.replace(\r\n          new RegExp(`url\\\\(#${escapeRegex(oldId)}\\\\)`, \"g\"),\r\n          `url(#${newId})`,\r\n        );\r\n      }\r\n      if (newValue !== attr.value) {\r\n        element.setAttribute(attr.localName, newValue);\r\n      }\r\n    }\r\n    // Also handle href=\"#id\" (for <use> elements etc.)\r\n    if (\r\n      (attr.localName === \"href\" || attr.localName === \"xlink:href\") &&\r\n      attr.value.startsWith(\"#\")\r\n    ) {\r\n      const refId = attr.value.slice(1);\r\n      if (idMap.has(refId)) {\r\n        if (attr.namespaceURI === XLINK_NS) {\r\n          element.setAttributeNS(XLINK_NS, \"href\", `#${idMap.get(refId)}`);\r\n        } else {\r\n          element.setAttribute(attr.localName, `#${idMap.get(refId)}`);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Recurse\r\n  for (const child of Array.from(element.children)) {\r\n    if (child instanceof SVGElement) {\r\n      rewriteUrlReferences(child, idMap);\r\n    }\r\n  }\r\n}\r\n\r\n/** Replace `currentColor` in fill/stroke/color attributes with the resolved color */\r\nfunction resolveCurrentColor(element: SVGElement, color: string): void {\r\n  for (const attr of Array.from(element.attributes)) {\r\n    if (attr.value === \"currentColor\") {\r\n      element.setAttribute(attr.localName, color);\r\n    }\r\n  }\r\n  for (const child of Array.from(element.children)) {\r\n    if (child instanceof SVGElement) {\r\n      resolveCurrentColor(child, color);\r\n    }\r\n  }\r\n}\r\n\r\nfunction escapeRegex(str: string): string {\r\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\r\n}\r\n","import type { FontCache, FontMapping, FontConfig } from \"../types.js\";\r\n\r\nconst FONT_TIMEOUT_MS = 10_000;\r\n\r\n/**\r\n * Create a font cache that loads and caches opentype.js Font objects.\r\n * Fonts are loaded on-demand from URLs provided in the font mapping.\r\n */\r\nexport function createFontCache(mapping: FontMapping): FontCache {\r\n  const cache = new Map<string, any>();\r\n  let opentypeModule: any = null;\r\n\r\n  async function loadOpentype(): Promise<any> {\r\n    if (opentypeModule) return opentypeModule;\r\n    opentypeModule = await import(\"opentype.js\");\r\n    return opentypeModule;\r\n  }\r\n\r\n  function getKey(family: string, weight?: string | number, style?: string): string {\r\n    return `${family}|${weight ?? \"normal\"}|${style ?? \"normal\"}`;\r\n  }\r\n\r\n  function normalizeWeight(w?: string | number): number {\r\n    if (w === undefined || w === \"normal\") return 400;\r\n    if (w === \"bold\") return 700;\r\n    return typeof w === \"string\" ? parseInt(w, 10) || 400 : w;\r\n  }\r\n\r\n  function normalizeStyle(s?: string): string {\r\n    return s === \"italic\" || s === \"oblique\" ? \"italic\" : \"normal\";\r\n  }\r\n\r\n  function findConfig(\r\n    family: string,\r\n    weight?: string | number,\r\n    style?: string,\r\n  ): { url: string; weight?: string | number; style?: string } | null {\r\n    const entry = mapping[family];\r\n    if (!entry) return null;\r\n\r\n    if (typeof entry === \"string\") {\r\n      return { url: entry };\r\n    }\r\n\r\n    if (!Array.isArray(entry)) {\r\n      return entry as FontConfig;\r\n    }\r\n\r\n    // Array of configs: find best match by weight + style\r\n    const targetWeight = normalizeWeight(weight);\r\n    const targetStyle = normalizeStyle(style);\r\n    let best: FontConfig | null = null;\r\n    let bestScore = -1;\r\n\r\n    for (const cfg of entry) {\r\n      let score = 0;\r\n      if (normalizeStyle(cfg.style) === targetStyle) score += 2;\r\n      if (normalizeWeight(cfg.weight) === targetWeight) score += 1;\r\n      if (score > bestScore) {\r\n        bestScore = score;\r\n        best = cfg;\r\n      }\r\n    }\r\n\r\n    return best ?? entry[0] ?? null;\r\n  }\r\n\r\n  return {\r\n    async getFont(family: string, weight?: string | number, style?: string) {\r\n      const key = getKey(family, weight, style);\r\n\r\n      if (cache.has(key)) {\r\n        return cache.get(key);\r\n      }\r\n\r\n      const config = findConfig(family, weight, style);\r\n      if (!config) return null;\r\n\r\n      const opentype = await loadOpentype();\r\n\r\n      try {\r\n        const controller = new AbortController();\r\n        const timer = setTimeout(() => controller.abort(), FONT_TIMEOUT_MS);\r\n        const response = await fetch(config.url, { signal: controller.signal });\r\n        clearTimeout(timer);\r\n        const buffer = await response.arrayBuffer();\r\n        const font = opentype.parse(buffer);\r\n        cache.set(key, font);\r\n        return font;\r\n      } catch (err) {\r\n        console.warn(`dom2svg: Failed to load font \"${family}\" from ${config.url}:`, err);\r\n        return null;\r\n      }\r\n    },\r\n\r\n    has(family: string): boolean {\r\n      return family in mapping;\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Convert a text string to an SVG <path> using an opentype.js font.\r\n */\r\nexport function textToPath(\r\n  font: any,\r\n  text: string,\r\n  x: number,\r\n  y: number,\r\n  fontSize: number,\r\n): string | null {\r\n  try {\r\n    const path = font.getPath(text, x, y, fontSize);\r\n    return path.toPathData(2);\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Clean a font-family string: strip quotes and take the first family.\r\n */\r\nexport function cleanFontFamily(fontFamily: string): string {\r\n  // Split on commas, take first, strip quotes and whitespace\r\n  const first = fontFamily.split(\",\")[0]?.trim() ?? fontFamily;\r\n  return first.replace(/^[\"']|[\"']$/g, \"\");\r\n}\r\n","import type { RenderContext } from \"../types.js\";\r\nimport { createSvgElement, setAttributes } from \"../utils/dom.js\";\r\n\r\nexport interface TextShadow {\r\n  offsetX: number;\r\n  offsetY: number;\r\n  blur: number;\r\n  color: string;\r\n}\r\n\r\n/**\r\n * Parse a CSS text-shadow value into an array of TextShadow objects.\r\n * Syntax: offsetX offsetY [blur] [color], ...\r\n * Color can appear before or after the numeric values.\r\n */\r\nexport function parseTextShadows(value: string): TextShadow[] {\r\n  if (!value || value === \"none\") return [];\r\n\r\n  const shadows: TextShadow[] = [];\r\n  const parts = splitTopLevelCommas(value);\r\n\r\n  for (const part of parts) {\r\n    const shadow = parseSingleTextShadow(part.trim());\r\n    if (shadow) shadows.push(shadow);\r\n  }\r\n\r\n  return shadows;\r\n}\r\n\r\nfunction splitTopLevelCommas(str: string): string[] {\r\n  const parts: string[] = [];\r\n  let depth = 0;\r\n  let current = \"\";\r\n  for (const char of str) {\r\n    if (char === \"(\") depth++;\r\n    else if (char === \")\") depth--;\r\n    if (char === \",\" && depth === 0) {\r\n      parts.push(current);\r\n      current = \"\";\r\n    } else {\r\n      current += char;\r\n    }\r\n  }\r\n  if (current) parts.push(current);\r\n  return parts;\r\n}\r\n\r\nfunction parseSingleTextShadow(value: string): TextShadow | null {\r\n  // Tokenize respecting parentheses\r\n  const tokens: string[] = [];\r\n  let current = \"\";\r\n  let depth = 0;\r\n\r\n  for (const char of value) {\r\n    if (char === \"(\") depth++;\r\n    else if (char === \")\") depth--;\r\n    if (char === \" \" && depth === 0 && current) {\r\n      tokens.push(current);\r\n      current = \"\";\r\n    } else {\r\n      current += char;\r\n    }\r\n  }\r\n  if (current) tokens.push(current);\r\n\r\n  const numericValues: number[] = [];\r\n  const colorParts: string[] = [];\r\n\r\n  for (const token of tokens) {\r\n    const num = parseFloat(token);\r\n    if (!isNaN(num) && (token.endsWith(\"px\") || token.match(/^-?[\\d.]+$/))) {\r\n      numericValues.push(num);\r\n    } else {\r\n      colorParts.push(token);\r\n    }\r\n  }\r\n\r\n  if (numericValues.length < 2) return null;\r\n\r\n  return {\r\n    offsetX: numericValues[0]!,\r\n    offsetY: numericValues[1]!,\r\n    blur: numericValues[2] ?? 0,\r\n    color: colorParts.join(\" \") || \"rgba(0, 0, 0, 0.5)\",\r\n  };\r\n}\r\n\r\n/**\r\n * Create an SVG filter that applies text-shadow effects.\r\n * Uses chained feDropShadow primitives, merging all shadows with the source.\r\n * Returns the filter ID, or null if no shadows.\r\n */\r\nexport function createTextShadowFilter(\r\n  shadows: TextShadow[],\r\n  ctx: RenderContext,\r\n): string | null {\r\n  if (shadows.length === 0) return null;\r\n\r\n  const id = ctx.idGenerator.next(\"tshadow\");\r\n  const filter = createSvgElement(ctx.svgDocument, \"filter\");\r\n  setAttributes(filter, {\r\n    id,\r\n    x: \"-50%\",\r\n    y: \"-50%\",\r\n    width: \"200%\",\r\n    height: \"200%\",\r\n  });\r\n\r\n  if (shadows.length === 1) {\r\n    // Single shadow: use feDropShadow (preserves source graphic automatically)\r\n    const s = shadows[0]!;\r\n    const feDrop = createSvgElement(ctx.svgDocument, \"feDropShadow\");\r\n    setAttributes(feDrop, {\r\n      dx: s.offsetX,\r\n      dy: s.offsetY,\r\n      stdDeviation: s.blur / 2,\r\n      \"flood-color\": s.color,\r\n      \"flood-opacity\": 1,\r\n    });\r\n    filter.appendChild(feDrop);\r\n  } else {\r\n    // Multiple shadows: chain feOffset + feGaussianBlur + feFlood + feComposite,\r\n    // then feMerge all shadow results with the source graphic.\r\n    const mergeInputs: string[] = [];\r\n\r\n    for (let i = 0; i < shadows.length; i++) {\r\n      const s = shadows[i]!;\r\n      const suffix = String(i);\r\n\r\n      // Offset the source alpha\r\n      const feOffset = createSvgElement(ctx.svgDocument, \"feOffset\");\r\n      setAttributes(feOffset, {\r\n        in: \"SourceAlpha\",\r\n        dx: s.offsetX,\r\n        dy: s.offsetY,\r\n        result: `off${suffix}`,\r\n      });\r\n      filter.appendChild(feOffset);\r\n\r\n      // Blur it\r\n      const feBlur = createSvgElement(ctx.svgDocument, \"feGaussianBlur\");\r\n      setAttributes(feBlur, {\r\n        in: `off${suffix}`,\r\n        stdDeviation: s.blur / 2,\r\n        result: `blur${suffix}`,\r\n      });\r\n      filter.appendChild(feBlur);\r\n\r\n      // Flood with shadow color\r\n      const feFlood = createSvgElement(ctx.svgDocument, \"feFlood\");\r\n      setAttributes(feFlood, {\r\n        \"flood-color\": s.color,\r\n        \"flood-opacity\": 1,\r\n        result: `color${suffix}`,\r\n      });\r\n      filter.appendChild(feFlood);\r\n\r\n      // Composite flood color with blurred alpha\r\n      const feComp = createSvgElement(ctx.svgDocument, \"feComposite\");\r\n      setAttributes(feComp, {\r\n        in: `color${suffix}`,\r\n        in2: `blur${suffix}`,\r\n        operator: \"in\",\r\n        result: `shadow${suffix}`,\r\n      });\r\n      filter.appendChild(feComp);\r\n\r\n      mergeInputs.push(`shadow${suffix}`);\r\n    }\r\n\r\n    // Merge all shadows + original source graphic\r\n    const feMerge = createSvgElement(ctx.svgDocument, \"feMerge\");\r\n    for (const input of mergeInputs) {\r\n      const node = createSvgElement(ctx.svgDocument, \"feMergeNode\");\r\n      node.setAttribute(\"in\", input);\r\n      feMerge.appendChild(node);\r\n    }\r\n    // Source graphic on top\r\n    const srcNode = createSvgElement(ctx.svgDocument, \"feMergeNode\");\r\n    srcNode.setAttribute(\"in\", \"SourceGraphic\");\r\n    feMerge.appendChild(srcNode);\r\n    filter.appendChild(feMerge);\r\n  }\r\n\r\n  ctx.defs.appendChild(filter);\r\n  return id;\r\n}\r\n","import type { RenderContext } from \"../types.js\";\r\nimport { createSvgElement, setAttributes } from \"../utils/dom.js\";\r\nimport { textToPath, cleanFontFamily } from \"../assets/fonts.js\";\r\nimport { parseTextShadows, createTextShadowFilter } from \"../assets/text-shadow.js\";\r\n\r\n/**\r\n * Render a DOM Text node as SVG <text> or <path> elements.\r\n * Uses Range API to get precise per-line positioning.\r\n * When textToPath is enabled and a font is available, renders as <path>.\r\n */\r\nexport async function renderTextNode(\r\n  textNode: Text,\r\n  rootElement: Element,\r\n  ctx: RenderContext,\r\n): Promise<SVGElement | null> {\r\n  const text = textNode.textContent;\r\n  if (!text || !text.trim()) return null;\r\n\r\n  const parent = textNode.parentElement;\r\n  if (!parent) return null;\r\n\r\n  const styles = window.getComputedStyle(parent);\r\n  if (styles.visibility === \"hidden\") return null;\r\n  const whiteSpace = styles.whiteSpace;\r\n  const rootRect = rootElement.getBoundingClientRect();\r\n\r\n  // Use Range to get per-line client rects\r\n  let rects: DOMRectList;\r\n  try {\r\n    const range = document.createRange();\r\n    range.selectNodeContents(textNode);\r\n    rects = range.getClientRects();\r\n  } catch {\r\n    return null;\r\n  }\r\n\r\n  if (rects.length === 0) return null;\r\n\r\n  const group = createSvgElement(ctx.svgDocument, \"g\");\r\n\r\n  // Determine if we should use path mode\r\n  const usePathMode = ctx.options.textToPath && ctx.fontCache;\r\n  const fontFamily = cleanFontFamily(styles.fontFamily);\r\n  const fontSize = parseFloat(styles.fontSize) || 16;\r\n  const fontWeight = styles.fontWeight;\r\n  const fontStyle = styles.fontStyle;\r\n\r\n  let font: any = null;\r\n  if (usePathMode && ctx.fontCache?.has(fontFamily)) {\r\n    font = await ctx.fontCache.getFont(fontFamily, fontWeight, fontStyle);\r\n  }\r\n\r\n  // Use font's actual ascender metric when available, otherwise 0.8 approximation\r\n  let ascenderRatio = 0.8;\r\n  if (font && font.ascender && font.unitsPerEm) {\r\n    ascenderRatio = font.ascender / font.unitsPerEm;\r\n  }\r\n\r\n  const lines = getTextLines(textNode, rootRect, ascenderRatio, whiteSpace);\r\n  const textTransform = styles.textTransform;\r\n\r\n  // Detect text-overflow: ellipsis\r\n  const needsEllipsis =\r\n    styles.textOverflow === \"ellipsis\" &&\r\n    styles.overflow !== \"visible\" &&\r\n    styles.whiteSpace === \"nowrap\" &&\r\n    parent.scrollWidth > parent.clientWidth;\r\n\r\n  for (const line of lines) {\r\n    let displayText = applyTextTransform(line.text, textTransform);\r\n\r\n    // Append ellipsis to the last line when text overflows\r\n    if (needsEllipsis && line === lines[lines.length - 1]) {\r\n      displayText = displayText.trimEnd() + \"\\u2026\";\r\n    }\r\n    if (font) {\r\n      // Path mode: convert text to <path>\r\n      const pathData = textToPath(font, displayText, line.x, line.y, fontSize);\r\n      if (pathData) {\r\n        const pathEl = createSvgElement(ctx.svgDocument, \"path\");\r\n        setAttributes(pathEl, {\r\n          d: pathData,\r\n          fill: styles.color,\r\n        });\r\n        group.appendChild(pathEl);\r\n      }\r\n    } else {\r\n      // Text mode: use <text> elements\r\n      const textEl = createSvgElement(ctx.svgDocument, \"text\");\r\n      setAttributes(textEl, {\r\n        x: line.x.toFixed(2),\r\n        y: line.y.toFixed(2),\r\n      });\r\n      applyTextStyles(textEl, styles, ctx);\r\n      textEl.textContent = displayText;\r\n      group.appendChild(textEl);\r\n    }\r\n  }\r\n\r\n  if (group.childNodes.length === 0) return null;\r\n\r\n  // Apply text-shadow filter if present\r\n  if (!ctx.compat.stripTextShadows) {\r\n    const textShadowValue = styles.textShadow;\r\n    if (textShadowValue && textShadowValue !== \"none\") {\r\n      const shadows = parseTextShadows(textShadowValue);\r\n      const filterId = createTextShadowFilter(shadows, ctx);\r\n      if (filterId) {\r\n        group.setAttribute(\"filter\", `url(#${filterId})`);\r\n      }\r\n    }\r\n  }\r\n\r\n  return group;\r\n}\r\n\r\ninterface TextLine {\r\n  text: string;\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\n/**\r\n * Compute the SVG baseline y from a Range rect.\r\n *\r\n * Range API returns the full line box (height includes line-height spacing).\r\n * SVG <text> y positions at the alphabetic baseline.\r\n * We center the font within the line box, then offset to the baseline:\r\n *   y = top + (lineBoxHeight - fontSize) / 2 + fontSize * ascenderRatio\r\n *\r\n * When an opentype font is available, we use its actual ascender metric.\r\n * Otherwise we fall back to 0.8 which approximates common Latin fonts.\r\n *\r\n * When the Range rect is inflated by tall inline siblings (e.g. KaTeX\r\n * strut/pstrut elements that are 3em inline-blocks), the parent element's\r\n * bounding rect gives the actual text area. We detect inflation by comparing\r\n * rectHeight against parentHeight and use the parent's metrics instead.\r\n */\r\nfunction baselineY(\r\n  rectTop: number,\r\n  rectHeight: number,\r\n  fontSize: number,\r\n  rootTop: number,\r\n  ascenderRatio: number = 0.8,\r\n  parentRect?: { top: number; height: number },\r\n): number {\r\n  let effectiveTop = rectTop;\r\n  let effectiveHeight = rectHeight;\r\n\r\n  // If the Range rect is much taller than the parent element, the line box\r\n  // was inflated by tall inline siblings (struts). Use the parent's bounds\r\n  // for a more accurate baseline calculation.\r\n  if (parentRect && rectHeight > fontSize * 2 && parentRect.height < rectHeight * 0.8) {\r\n    effectiveTop = parentRect.top;\r\n    effectiveHeight = parentRect.height;\r\n  }\r\n\r\n  const topPadding = (effectiveHeight - fontSize) / 2;\r\n  return effectiveTop - rootTop + topPadding + fontSize * ascenderRatio;\r\n}\r\n\r\n/** Get per-line text and positions using Range API */\r\nfunction getTextLines(textNode: Text, rootRect: DOMRect, ascenderRatio: number = 0.8, whiteSpace: string = \"normal\"): TextLine[] {\r\n  const lines: TextLine[] = [];\r\n  const text = textNode.textContent || \"\";\r\n  if (!text) return lines;\r\n\r\n  const parent = textNode.parentElement;\r\n  if (!parent) return lines;\r\n\r\n  const styles = window.getComputedStyle(parent);\r\n  const fontSize = parseFloat(styles.fontSize) || 16;\r\n\r\n  // Get parent element's bounding rect for inflated line box detection.\r\n  // When tall inline siblings (e.g. KaTeX struts) inflate the Range rect,\r\n  // the parent element's rect reflects the actual text area.\r\n  const pRect = parent.getBoundingClientRect();\r\n  const parentRect = { top: pRect.top, height: pRect.height };\r\n\r\n  const range = document.createRange();\r\n  range.selectNodeContents(textNode);\r\n  const rects = range.getClientRects();\r\n\r\n  if (rects.length === 0) return lines;\r\n\r\n  // Determine per-line rects. Range.getClientRects() normally returns one\r\n  // rect per visual line, but in some cases (e.g. text inside flex/grid\r\n  // columns with overflow clipping) it may return a single bounding rect\r\n  // even when the text wraps. Detect this by probing character positions.\r\n  let lineRects: DOMRect[];\r\n\r\n  if (rects.length === 1) {\r\n    const rect = rects[0]!;\r\n    if (text.length > 1 && textActuallyWraps(textNode, range, text.length, fontSize)) {\r\n      lineRects = discoverLineRects(textNode, range, text.length, fontSize);\r\n    } else {\r\n      lines.push({\r\n        text: normalizeWhitespace(text, whiteSpace),\r\n        x: rect.left - rootRect.left,\r\n        y: baselineY(rect.top, rect.height, fontSize, rootRect.top, ascenderRatio, parentRect),\r\n      });\r\n      return lines;\r\n    }\r\n  } else {\r\n    lineRects = Array.from(rects);\r\n  }\r\n\r\n  // Multi-line: use line rects as guides, binary search for breakpoints.\r\n  let charStart = 0;\r\n\r\n  for (let lineIdx = 0; lineIdx < lineRects.length; lineIdx++) {\r\n    const lineRect = lineRects[lineIdx]!;\r\n    const isLastLine = lineIdx === lineRects.length - 1;\r\n\r\n    let charEnd: number;\r\n    if (isLastLine) {\r\n      charEnd = text.length;\r\n    } else {\r\n      // Binary search for the first character past the current line\r\n      const currentTop = lineRect.top;\r\n      charEnd = binarySearchLineBreak(textNode, range, charStart, text.length, currentTop, fontSize);\r\n    }\r\n\r\n    const lineText = normalizeWhitespace(text.slice(charStart, charEnd), whiteSpace);\r\n    if (lineText) {\r\n      lines.push({\r\n        text: lineText,\r\n        x: lineRect.left - rootRect.left,\r\n        y: baselineY(lineRect.top, lineRect.height, fontSize, rootRect.top, ascenderRatio, parentRect),\r\n      });\r\n    }\r\n    charStart = charEnd;\r\n  }\r\n\r\n  return lines;\r\n}\r\n\r\n/** Binary search for the first character that falls past the current visual line */\r\nfunction binarySearchLineBreak(\r\n  textNode: Text,\r\n  range: Range,\r\n  start: number,\r\n  end: number,\r\n  currentLineTop: number,\r\n  fontSize: number,\r\n): number {\r\n  while (start < end) {\r\n    const mid = Math.floor((start + end) / 2);\r\n    try {\r\n      range.setStart(textNode, mid);\r\n      range.setEnd(textNode, mid + 1);\r\n    } catch {\r\n      // Can throw on multi-byte characters (emoji, CJK surrogate pairs)\r\n      start = mid + 1;\r\n      continue;\r\n    }\r\n    const rects = range.getClientRects();\r\n    if (rects.length === 0) {\r\n      start = mid + 1;\r\n      continue;\r\n    }\r\n    if (Math.abs(rects[0]!.top - currentLineTop) > fontSize * 0.5) {\r\n      end = mid; // This char is past the current line, search earlier\r\n    } else {\r\n      start = mid + 1; // Still on current line\r\n    }\r\n  }\r\n  return start;\r\n}\r\n\r\n/** Check if text wraps despite getClientRects() returning a single rect */\r\nfunction textActuallyWraps(\r\n  textNode: Text,\r\n  range: Range,\r\n  textLength: number,\r\n  fontSize: number,\r\n): boolean {\r\n  if (textLength <= 1) return false;\r\n  try {\r\n    range.setStart(textNode, 0);\r\n    range.setEnd(textNode, 1);\r\n    const firstRects = range.getClientRects();\r\n    range.setStart(textNode, textLength - 1);\r\n    range.setEnd(textNode, textLength);\r\n    const lastRects = range.getClientRects();\r\n    if (firstRects.length > 0 && lastRects.length > 0) {\r\n      return Math.abs(lastRects[0]!.top - firstRects[0]!.top) > fontSize * 0.5;\r\n    }\r\n  } catch {\r\n    // Ignore errors with multi-byte characters\r\n  }\r\n  return false;\r\n}\r\n\r\n/** Discover per-line DOMRects by scanning character positions */\r\nfunction discoverLineRects(\r\n  textNode: Text,\r\n  range: Range,\r\n  textLength: number,\r\n  fontSize: number,\r\n): DOMRect[] {\r\n  const lineRects: DOMRect[] = [];\r\n  let currentLineTop = -Infinity;\r\n  for (let i = 0; i < textLength; i++) {\r\n    try {\r\n      range.setStart(textNode, i);\r\n      range.setEnd(textNode, i + 1);\r\n      const charRects = range.getClientRects();\r\n      if (charRects.length === 0) continue;\r\n      const charRect = charRects[0]!;\r\n      if (Math.abs(charRect.top - currentLineTop) > fontSize * 0.5) {\r\n        lineRects.push(charRect);\r\n        currentLineTop = charRect.top;\r\n      }\r\n    } catch {\r\n      continue;\r\n    }\r\n  }\r\n  return lineRects;\r\n}\r\n\r\n/**\r\n * Normalize text content to match CSS whitespace rendering.\r\n * SVG text elements use xml:space=\"preserve\" so we must collapse\r\n * whitespace ourselves to match how CSS renders the text.\r\n */\r\nfunction normalizeWhitespace(text: string, whiteSpace: string): string {\r\n  const preserves = whiteSpace === \"pre\" || whiteSpace === \"pre-wrap\" || whiteSpace === \"break-spaces\";\r\n  if (preserves) return text;\r\n  if (whiteSpace === \"pre-line\") {\r\n    // Collapse spaces/tabs but preserve newlines\r\n    return text.replace(/[^\\S\\n]+/g, \" \");\r\n  }\r\n  // white-space: normal | nowrap — collapse all whitespace to single spaces\r\n  return text.replace(/\\s+/g, \" \");\r\n}\r\n\r\n/** Apply CSS text-transform to a string */\r\nfunction applyTextTransform(text: string, transform: string): string {\r\n  switch (transform) {\r\n    case \"uppercase\": return text.toUpperCase();\r\n    case \"lowercase\": return text.toLowerCase();\r\n    case \"capitalize\": return text.replace(/\\b\\w/g, (c) => c.toUpperCase());\r\n    default: return text;\r\n  }\r\n}\r\n\r\n/** Apply CSS text styles to an SVG <text> element */\r\nfunction applyTextStyles(\r\n  textEl: SVGTextElement,\r\n  styles: CSSStyleDeclaration,\r\n  ctx: RenderContext,\r\n): void {\r\n  setAttributes(textEl, {\r\n    \"font-family\": styles.fontFamily,\r\n    \"font-size\": styles.fontSize,\r\n    \"font-weight\": styles.fontWeight,\r\n    \"font-style\": styles.fontStyle,\r\n    fill: styles.color,\r\n  });\r\n\r\n  // Preserve whitespace so that leading/trailing spaces in normalized text\r\n  // are rendered (matching CSS's inline whitespace between elements).\r\n  if (!ctx.compat.stripXmlSpace) {\r\n    textEl.setAttribute(\"xml:space\", \"preserve\");\r\n  }\r\n\r\n  if (styles.letterSpacing && styles.letterSpacing !== \"normal\") {\r\n    textEl.setAttribute(\"letter-spacing\", styles.letterSpacing);\r\n  }\r\n\r\n  if (styles.wordSpacing && styles.wordSpacing !== \"normal\") {\r\n    textEl.setAttribute(\"word-spacing\", styles.wordSpacing);\r\n  }\r\n\r\n  if (styles.textDecoration && styles.textDecoration !== \"none\") {\r\n    const decs: string[] = [];\r\n    if (styles.textDecoration.includes(\"underline\")) decs.push(\"underline\");\r\n    if (styles.textDecoration.includes(\"line-through\")) decs.push(\"line-through\");\r\n    if (decs.length > 0) {\r\n      textEl.setAttribute(\"text-decoration\", decs.join(\" \"));\r\n    }\r\n  }\r\n\r\n  // NOTE: We intentionally do NOT set text-anchor based on text-align.\r\n  // Range API getClientRects() returns the actual rendered left edge of\r\n  // each line, which already accounts for centering/right-alignment.\r\n  // Setting text-anchor: middle would re-center around that left edge,\r\n  // shifting text incorrectly.\r\n}\r\n","import type { RenderContext } from \"../types.js\";\r\nimport {\r\n  isElement,\r\n  isTextNode,\r\n  isSvgElement,\r\n} from \"../utils/dom.js\";\r\nimport {\r\n  isInvisible,\r\n  createsStackingContext,\r\n  getZIndex,\r\n  isPositioned,\r\n  isFloat,\r\n  isInlineLevel,\r\n} from \"./styles.js\";\r\nimport { getRelativeBox } from \"../utils/geometry.js\";\r\nimport {\r\n  renderHtmlElement,\r\n  renderPseudoAfter,\r\n  getChildTarget,\r\n} from \"../renderers/html-element.js\";\r\nimport { renderSvgElement } from \"../renderers/svg-element.js\";\r\nimport { renderTextNode } from \"../renderers/text-node.js\";\r\n\r\n/**\r\n * Recursively walk the DOM tree and render each node into SVG.\r\n * Returns the SVG group for this subtree.\r\n */\r\nexport async function walkElement(\r\n  element: Element,\r\n  rootElement: Element,\r\n  ctx: RenderContext,\r\n): Promise<SVGElement | null> {\r\n  const styles = window.getComputedStyle(element);\r\n\r\n  // Skip invisible elements\r\n  if (isInvisible(styles)) return null;\r\n\r\n  // Check exclude option\r\n  if (shouldExclude(element, ctx)) return null;\r\n\r\n  // Custom handler\r\n  if (ctx.options.handler) {\r\n    try {\r\n      const result = ctx.options.handler(element, ctx);\r\n      if (result !== null) return result;\r\n    } catch (err) {\r\n      console.warn(\"dom2svg: Custom handler threw for element:\", element, err);\r\n    }\r\n  }\r\n\r\n  // SVG element — clone directly\r\n  if (isSvgElement(element) && element !== rootElement) {\r\n    const box = getRelativeBox(element, rootElement);\r\n    const clone = renderSvgElement(element, ctx);\r\n\r\n    // Position the cloned SVG at its computed location\r\n    if (element.tagName.toLowerCase() === \"svg\") {\r\n      clone.setAttribute(\"x\", String(box.x));\r\n      clone.setAttribute(\"y\", String(box.y));\r\n      clone.setAttribute(\"width\", String(box.width));\r\n      clone.setAttribute(\"height\", String(box.height));\r\n\r\n      // Preserve overflow:visible from CSS — many frameworks (SvelteFlow,\r\n      // React Flow) use CSS to set overflow:visible on edge SVGs so paths\r\n      // can extend beyond the SVG viewport. Without this, cloned SVGs\r\n      // default to overflow:hidden and clip the content.\r\n      if (styles.overflow === \"visible\") {\r\n        clone.setAttribute(\"overflow\", \"visible\");\r\n      }\r\n    }\r\n\r\n    return clone;\r\n  }\r\n\r\n  // HTML element — render backgrounds/borders, then recurse children\r\n  const group = await renderHtmlElement(element, rootElement, ctx);\r\n  const childTarget = getChildTarget(group);\r\n\r\n  // Apply opacity (skip in compat mode — group opacity causes Inkscape to rasterize subtrees)\r\n  if (!ctx.compat.stripGroupOpacity) {\r\n    const opacity = parseFloat(styles.opacity);\r\n    if (opacity < 1) {\r\n      group.setAttribute(\"opacity\", String(opacity));\r\n    }\r\n  }\r\n\r\n  // Walk children in CSS paint order (z-index / stacking context aware)\r\n  const sortedChildren = sortChildrenByPaintOrder(element);\r\n  for (const child of sortedChildren) {\r\n    if (isTextNode(child)) {\r\n      const textSvg = await renderTextNode(child, rootElement, ctx);\r\n      if (textSvg) childTarget.appendChild(textSvg);\r\n    } else if (isElement(child)) {\r\n      const childSvg = await walkElement(child, rootElement, ctx);\r\n      if (childSvg) childTarget.appendChild(childSvg);\r\n    }\r\n  }\r\n\r\n  // Render ::after pseudo-element\r\n  await renderPseudoAfter(element, rootElement, ctx, group);\r\n\r\n  return group;\r\n}\r\n\r\n/**\r\n * Sort child nodes into CSS paint order per CSS 2.2 Appendix E:\r\n * 1. Stacking contexts with negative z-index (sorted ascending)\r\n * 2. In-flow, non-positioned, block-level descendants (tree order)\r\n * 3. Non-positioned floats (tree order)\r\n * 4. In-flow, non-positioned, inline-level descendants + text nodes (tree order)\r\n * 5. Positioned with z-index auto/0 + opacity/transform stacking contexts (tree order)\r\n * 6. Stacking contexts with positive z-index (sorted ascending)\r\n */\r\nfunction sortChildrenByPaintOrder(element: Element): Node[] {\r\n  const children = Array.from(element.childNodes);\r\n\r\n  // Fast path: no element children, just text nodes\r\n  if (!children.some((c) => isElement(c))) return children;\r\n\r\n  const negativeZIndex: { node: Element; z: number }[] = [];\r\n  const blocks: Node[] = [];\r\n  const floats: Element[] = [];\r\n  const inlinesAndText: Node[] = [];\r\n  const positioned: Element[] = [];\r\n  const positiveZIndex: { node: Element; z: number }[] = [];\r\n\r\n  for (const child of children) {\r\n    if (isTextNode(child)) {\r\n      inlinesAndText.push(child);\r\n      continue;\r\n    }\r\n\r\n    if (!isElement(child)) continue;\r\n\r\n    const childStyles = window.getComputedStyle(child);\r\n    const z = getZIndex(childStyles);\r\n    const hasStackingCtx = createsStackingContext(childStyles);\r\n    const pos = isPositioned(childStyles);\r\n\r\n    // Elements with explicit z-index that create stacking contexts\r\n    if (hasStackingCtx && z < 0) {\r\n      negativeZIndex.push({ node: child, z });\r\n    } else if (hasStackingCtx && z > 0) {\r\n      positiveZIndex.push({ node: child, z });\r\n    } else if (pos || hasStackingCtx) {\r\n      // Positioned with z-index auto/0, or non-positioned stacking contexts\r\n      positioned.push(child);\r\n    } else if (isFloat(childStyles)) {\r\n      floats.push(child);\r\n    } else if (isInlineLevel(childStyles)) {\r\n      inlinesAndText.push(child);\r\n    } else {\r\n      // Block-level, in-flow, non-positioned\r\n      blocks.push(child);\r\n    }\r\n  }\r\n\r\n  // Sort by z-index (ascending), stable within same z\r\n  negativeZIndex.sort((a, b) => a.z - b.z);\r\n  positiveZIndex.sort((a, b) => a.z - b.z);\r\n\r\n  const result: Node[] = [];\r\n  for (const { node } of negativeZIndex) result.push(node);\r\n  for (const node of blocks) result.push(node);\r\n  for (const node of floats) result.push(node);\r\n  for (const node of inlinesAndText) result.push(node);\r\n  for (const node of positioned) result.push(node);\r\n  for (const { node } of positiveZIndex) result.push(node);\r\n\r\n  return result;\r\n}\r\n\r\n/** Check if an element should be excluded */\r\nfunction shouldExclude(element: Element, ctx: RenderContext): boolean {\r\n  const exclude = ctx.options.exclude;\r\n  if (!exclude) return false;\r\n\r\n  if (typeof exclude === \"string\") {\r\n    return element.matches(exclude);\r\n  }\r\n\r\n  return exclude(element);\r\n}\r\n","import type { SvgCompat, SvgCompatConfig } from \"./types.js\";\r\n\r\n/** Full fidelity — all features enabled (current default behavior) */\r\nexport const FULL_PRESET: SvgCompatConfig = {\r\n  useClipPathForOverflow: false,\r\n  stripFilters: false,\r\n  stripBoxShadows: false,\r\n  stripMaskImage: false,\r\n  stripTextShadows: false,\r\n  avoidStyleAttributes: false,\r\n  stripXmlSpace: false,\r\n  stripGroupOpacity: false,\r\n  inlineClipPathTransforms: false,\r\n};\r\n\r\n/** Inkscape / LaTeX safe — strips unsupported SVG features */\r\nexport const INKSCAPE_PRESET: SvgCompatConfig = {\r\n  useClipPathForOverflow: true,\r\n  stripFilters: true,\r\n  stripBoxShadows: true,\r\n  stripMaskImage: true,\r\n  stripTextShadows: true,\r\n  avoidStyleAttributes: true,\r\n  stripXmlSpace: true,\r\n  stripGroupOpacity: true,\r\n  inlineClipPathTransforms: true,\r\n};\r\n\r\n/** Resolve a compat option to a full config object */\r\nexport function resolveCompat(compat?: SvgCompat): SvgCompatConfig {\r\n  if (!compat || compat === \"full\") return FULL_PRESET;\r\n  if (compat === \"inkscape\") return INKSCAPE_PRESET;\r\n  return compat;\r\n}\r\n","import type {\r\n  DomToSvgOptions,\r\n  DomToSvgResult,\r\n  RenderContext,\r\n  BorderRadii,\r\n} from \"./types.js\";\r\nimport { SVG_NS, XMLNS_NS, createSvgElement, setAttributes } from \"./utils/dom.js\";\r\nimport { createIdGenerator } from \"./utils/id-generator.js\";\r\nimport { walkElement } from \"./core/traversal.js\";\r\nimport { createFontCache } from \"./assets/fonts.js\";\r\nimport { parseBorderRadii, clampRadii, hasRadius, isUniformRadius, hasOverflowClip } from \"./core/styles.js\";\r\nimport { buildRoundedRectPath } from \"./utils/geometry.js\";\r\nimport { resolveCompat } from \"./compat.js\";\r\n\r\nexport type {\r\n  DomToSvgOptions,\r\n  DomToSvgResult,\r\n  FontConfig,\r\n  FontMapping,\r\n  SvgCompat,\r\n  SvgCompatConfig,\r\n} from \"./types.js\";\r\n\r\n/**\r\n * Convert a DOM element (including hybrid HTML/SVG) to a self-contained SVG.\r\n *\r\n * @param element - The root DOM element to convert\r\n * @param options - Configuration options\r\n * @returns A result object with the SVG and serialization helpers\r\n */\r\nexport async function domToSvg(\r\n  element: Element,\r\n  options: DomToSvgOptions = {},\r\n): Promise<DomToSvgResult> {\r\n  const padding = options.padding ?? 0;\r\n  const rect = element.getBoundingClientRect();\r\n\r\n  const width = rect.width + padding * 2;\r\n  const height = rect.height + padding * 2;\r\n\r\n  // Create an SVG document\r\n  const svgDocument = document.implementation.createDocument(SVG_NS, \"svg\", null);\r\n  const svg = svgDocument.documentElement as unknown as SVGSVGElement;\r\n\r\n  svg.setAttribute(\"xmlns\", SVG_NS);\r\n  svg.setAttributeNS(XMLNS_NS, \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\r\n  setAttributes(svg as unknown as SVGElement, {\r\n    width,\r\n    height,\r\n    viewBox: `${-padding} ${-padding} ${width} ${height}`,\r\n  });\r\n\r\n  // Create <defs>\r\n  const defs = createSvgElement(svgDocument, \"defs\") as SVGDefsElement;\r\n  svg.appendChild(defs);\r\n\r\n  // Background\r\n  if (options.background) {\r\n    const bgRect = createSvgElement(svgDocument, \"rect\");\r\n    setAttributes(bgRect, {\r\n      x: -padding,\r\n      y: -padding,\r\n      width,\r\n      height,\r\n      fill: options.background,\r\n    });\r\n    svg.appendChild(bgRect);\r\n  }\r\n\r\n  // Build render context\r\n  const ctx: RenderContext = {\r\n    svgDocument,\r\n    defs,\r\n    idGenerator: createIdGenerator(),\r\n    options,\r\n    compat: resolveCompat(options.compat),\r\n    opacity: 1,\r\n  };\r\n\r\n  // Initialize font cache if textToPath is enabled\r\n  if (options.textToPath && options.fonts) {\r\n    ctx.fontCache = createFontCache(options.fonts);\r\n  }\r\n\r\n  // Walk the DOM tree and render\r\n  const rootGroup = await walkElement(element, element, ctx);\r\n  if (rootGroup) {\r\n    // Apply border-radius clipping at the SVG level for the root element.\r\n    // This is done here instead of in renderHtmlElement to avoid subpixel\r\n    // mask truncation issues that occur when the mask and viewBox compete.\r\n    const rootStyles = window.getComputedStyle(element);\r\n    const rootRadii = clampRadii(parseBorderRadii(rootStyles), rect.width, rect.height);\r\n    if (hasOverflowClip(rootStyles) && hasRadius(rootRadii)) {\r\n      const clipId = ctx.idGenerator.next(\"clip\");\r\n      const clipPath = createSvgElement(svgDocument, \"clipPath\");\r\n      clipPath.setAttribute(\"id\", clipId);\r\n      const clipShape = createRootClipShape(svgDocument, rect.width, rect.height, rootRadii);\r\n      clipPath.appendChild(clipShape);\r\n      defs.appendChild(clipPath);\r\n      rootGroup.setAttribute(\"clip-path\", `url(#${clipId})`);\r\n    }\r\n    svg.appendChild(rootGroup);\r\n  }\r\n\r\n  // Remove defs if empty\r\n  if (defs.childNodes.length === 0) {\r\n    svg.removeChild(defs);\r\n  }\r\n\r\n  return createResult(svg);\r\n}\r\n\r\n/** Create a rounded-rect shape for the root element's clipPath */\r\nfunction createRootClipShape(\r\n  doc: Document,\r\n  width: number,\r\n  height: number,\r\n  radii: BorderRadii,\r\n): SVGElement {\r\n  if (isUniformRadius(radii)) {\r\n    const rect = createSvgElement(doc, \"rect\");\r\n    setAttributes(rect, { x: 0, y: 0, width, height, rx: radii.topLeft[0], ry: radii.topLeft[1] });\r\n    return rect;\r\n  }\r\n  const path = createSvgElement(doc, \"path\");\r\n  path.setAttribute(\"d\", buildRoundedRectPath(0, 0, width, height, radii));\r\n  return path;\r\n}\r\n\r\nfunction createResult(svg: SVGSVGElement): DomToSvgResult {\r\n  return {\r\n    svg,\r\n    toString() {\r\n      const serializer = new XMLSerializer();\r\n      const xmlStr = serializer.serializeToString(svg);\r\n      return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n${xmlStr}`;\r\n    },\r\n    toBlob() {\r\n      const str = this.toString();\r\n      return new Blob([str], { type: \"image/svg+xml;charset=utf-8\" });\r\n    },\r\n    download(filename = \"export.svg\") {\r\n      const blob = this.toBlob();\r\n      const url = URL.createObjectURL(blob);\r\n      const a = document.createElement(\"a\");\r\n      a.href = url;\r\n      a.download = filename;\r\n      a.click();\r\n      setTimeout(() => URL.revokeObjectURL(url), 60_000);\r\n    },\r\n  };\r\n}\r\n"],"mappings":"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","names":["scale","scale","parseAngle","parseLengthValue","textEl","baselineY","splitTopLevelCommas"]}